// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v3.21.12
// source: problemset.proto

package problemset

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
	Problem_AddProblem_FullMethodName        = "/problemset.Problem/AddProblem"
	Problem_DeleteProblem_FullMethodName     = "/problemset.Problem/DeleteProblem"
	Problem_GetProblemContent_FullMethodName = "/problemset.Problem/GetProblemContent"
	Problem_UpdateProblem_FullMethodName     = "/problemset.Problem/UpdateProblem"
	Problem_SearchProblem_FullMethodName     = "/problemset.Problem/SearchProblem"
)

// ProblemClient is the client API for Problem service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 题目
type ProblemClient interface {
	// 添加问题，客服权限
	AddProblem(ctx context.Context, in *AddProblemReq, opts ...grpc.CallOption) (*AddProblemResp, error)
	// 删除问题，客服权限
	DeleteProblem(ctx context.Context, in *DeleteProblemReq, opts ...grpc.CallOption) (*DeleteProblemResp, error)
	// 获取问题信息，可缓存
	GetProblemContent(ctx context.Context, in *GetProblemContentReq, opts ...grpc.CallOption) (*GetProblemContentResp, error)
	// 更新问题，客服权限
	UpdateProblem(ctx context.Context, in *UpdateProblemReq, opts ...grpc.CallOption) (*UpdateProblemResp, error)
	// 分页搜索题目
	SearchProblem(ctx context.Context, in *SearchProblemReq, opts ...grpc.CallOption) (*SearchProblemResp, error)
}

type problemClient struct {
	cc grpc.ClientConnInterface
}

func NewProblemClient(cc grpc.ClientConnInterface) ProblemClient {
	return &problemClient{cc}
}

func (c *problemClient) AddProblem(ctx context.Context, in *AddProblemReq, opts ...grpc.CallOption) (*AddProblemResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddProblemResp)
	err := c.cc.Invoke(ctx, Problem_AddProblem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *problemClient) DeleteProblem(ctx context.Context, in *DeleteProblemReq, opts ...grpc.CallOption) (*DeleteProblemResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteProblemResp)
	err := c.cc.Invoke(ctx, Problem_DeleteProblem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *problemClient) GetProblemContent(ctx context.Context, in *GetProblemContentReq, opts ...grpc.CallOption) (*GetProblemContentResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProblemContentResp)
	err := c.cc.Invoke(ctx, Problem_GetProblemContent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *problemClient) UpdateProblem(ctx context.Context, in *UpdateProblemReq, opts ...grpc.CallOption) (*UpdateProblemResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateProblemResp)
	err := c.cc.Invoke(ctx, Problem_UpdateProblem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *problemClient) SearchProblem(ctx context.Context, in *SearchProblemReq, opts ...grpc.CallOption) (*SearchProblemResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchProblemResp)
	err := c.cc.Invoke(ctx, Problem_SearchProblem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProblemServer is the server API for Problem service.
// All implementations must embed UnimplementedProblemServer
// for forward compatibility
//
// 题目
type ProblemServer interface {
	// 添加问题，客服权限
	AddProblem(context.Context, *AddProblemReq) (*AddProblemResp, error)
	// 删除问题，客服权限
	DeleteProblem(context.Context, *DeleteProblemReq) (*DeleteProblemResp, error)
	// 获取问题信息，可缓存
	GetProblemContent(context.Context, *GetProblemContentReq) (*GetProblemContentResp, error)
	// 更新问题，客服权限
	UpdateProblem(context.Context, *UpdateProblemReq) (*UpdateProblemResp, error)
	// 分页搜索题目
	SearchProblem(context.Context, *SearchProblemReq) (*SearchProblemResp, error)
	mustEmbedUnimplementedProblemServer()
}

// UnimplementedProblemServer must be embedded to have forward compatible implementations.
type UnimplementedProblemServer struct {
}

func (UnimplementedProblemServer) AddProblem(context.Context, *AddProblemReq) (*AddProblemResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddProblem not implemented")
}
func (UnimplementedProblemServer) DeleteProblem(context.Context, *DeleteProblemReq) (*DeleteProblemResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteProblem not implemented")
}
func (UnimplementedProblemServer) GetProblemContent(context.Context, *GetProblemContentReq) (*GetProblemContentResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProblemContent not implemented")
}
func (UnimplementedProblemServer) UpdateProblem(context.Context, *UpdateProblemReq) (*UpdateProblemResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProblem not implemented")
}
func (UnimplementedProblemServer) SearchProblem(context.Context, *SearchProblemReq) (*SearchProblemResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchProblem not implemented")
}
func (UnimplementedProblemServer) mustEmbedUnimplementedProblemServer() {}

// UnsafeProblemServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProblemServer will
// result in compilation errors.
type UnsafeProblemServer interface {
	mustEmbedUnimplementedProblemServer()
}

func RegisterProblemServer(s grpc.ServiceRegistrar, srv ProblemServer) {
	s.RegisterService(&Problem_ServiceDesc, srv)
}

func _Problem_AddProblem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddProblemReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProblemServer).AddProblem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Problem_AddProblem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProblemServer).AddProblem(ctx, req.(*AddProblemReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Problem_DeleteProblem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteProblemReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProblemServer).DeleteProblem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Problem_DeleteProblem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProblemServer).DeleteProblem(ctx, req.(*DeleteProblemReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Problem_GetProblemContent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProblemContentReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProblemServer).GetProblemContent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Problem_GetProblemContent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProblemServer).GetProblemContent(ctx, req.(*GetProblemContentReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Problem_UpdateProblem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateProblemReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProblemServer).UpdateProblem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Problem_UpdateProblem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProblemServer).UpdateProblem(ctx, req.(*UpdateProblemReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Problem_SearchProblem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchProblemReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProblemServer).SearchProblem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Problem_SearchProblem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProblemServer).SearchProblem(ctx, req.(*SearchProblemReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Problem_ServiceDesc is the grpc.ServiceDesc for Problem service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Problem_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "problemset.Problem",
	HandlerType: (*ProblemServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddProblem",
			Handler:    _Problem_AddProblem_Handler,
		},
		{
			MethodName: "DeleteProblem",
			Handler:    _Problem_DeleteProblem_Handler,
		},
		{
			MethodName: "GetProblemContent",
			Handler:    _Problem_GetProblemContent_Handler,
		},
		{
			MethodName: "UpdateProblem",
			Handler:    _Problem_UpdateProblem_Handler,
		},
		{
			MethodName: "SearchProblem",
			Handler:    _Problem_SearchProblem_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "problemset.proto",
}

const (
	Tag_AddTags_FullMethodName           = "/problemset.Tag/AddTags"
	Tag_DeleteTags_FullMethodName        = "/problemset.Tag/DeleteTags"
	Tag_MustDeleteTags_FullMethodName    = "/problemset.Tag/MustDeleteTags"
	Tag_UpdateTags_FullMethodName        = "/problemset.Tag/UpdateTags"
	Tag_GetAllTags_FullMethodName        = "/problemset.Tag/GetAllTags"
	Tag_ProblemAddTags_FullMethodName    = "/problemset.Tag/ProblemAddTags"
	Tag_ProblemDeleteTags_FullMethodName = "/problemset.Tag/ProblemDeleteTags"
	Tag_GetProblemTags_FullMethodName    = "/problemset.Tag/GetProblemTags"
)

// TagClient is the client API for Tag service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 标签
type TagClient interface {
	// 添加标签，客服权限
	AddTags(ctx context.Context, in *AddTagsReq, opts ...grpc.CallOption) (*AddTagsResp, error)
	// 删除标签，客服权限
	DeleteTags(ctx context.Context, in *DeleteTagsReq, opts ...grpc.CallOption) (*DeleteTagsResp, error)
	// 强行删除标签，管理员权限
	MustDeleteTags(ctx context.Context, in *MustDeleteTagsReq, opts ...grpc.CallOption) (*MustDeleteTagsResp, error)
	// 更新标签，客服权限
	UpdateTags(ctx context.Context, in *UpdateTagsReq, opts ...grpc.CallOption) (*UpdateTagsResp, error)
	// 获取所有标签，可缓存
	GetAllTags(ctx context.Context, in *GetAllTagsReq, opts ...grpc.CallOption) (*GetAllTagsResp, error)
	// 给题目添加标签，最多5个，客服权限
	ProblemAddTags(ctx context.Context, in *ProblemAddTagsReq, opts ...grpc.CallOption) (*ProblemAddTagsResp, error)
	// 给题目删除标签，客服权限
	ProblemDeleteTags(ctx context.Context, in *ProblemDeleteTagsReq, opts ...grpc.CallOption) (*ProblemDeleteTagsResp, error)
	// 获取一个题目的所有标签，可缓存
	GetProblemTags(ctx context.Context, in *GetProblemTagsReq, opts ...grpc.CallOption) (*GetProblemTagsResp, error)
}

type tagClient struct {
	cc grpc.ClientConnInterface
}

func NewTagClient(cc grpc.ClientConnInterface) TagClient {
	return &tagClient{cc}
}

func (c *tagClient) AddTags(ctx context.Context, in *AddTagsReq, opts ...grpc.CallOption) (*AddTagsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddTagsResp)
	err := c.cc.Invoke(ctx, Tag_AddTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagClient) DeleteTags(ctx context.Context, in *DeleteTagsReq, opts ...grpc.CallOption) (*DeleteTagsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteTagsResp)
	err := c.cc.Invoke(ctx, Tag_DeleteTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagClient) MustDeleteTags(ctx context.Context, in *MustDeleteTagsReq, opts ...grpc.CallOption) (*MustDeleteTagsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MustDeleteTagsResp)
	err := c.cc.Invoke(ctx, Tag_MustDeleteTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagClient) UpdateTags(ctx context.Context, in *UpdateTagsReq, opts ...grpc.CallOption) (*UpdateTagsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateTagsResp)
	err := c.cc.Invoke(ctx, Tag_UpdateTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagClient) GetAllTags(ctx context.Context, in *GetAllTagsReq, opts ...grpc.CallOption) (*GetAllTagsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAllTagsResp)
	err := c.cc.Invoke(ctx, Tag_GetAllTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagClient) ProblemAddTags(ctx context.Context, in *ProblemAddTagsReq, opts ...grpc.CallOption) (*ProblemAddTagsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProblemAddTagsResp)
	err := c.cc.Invoke(ctx, Tag_ProblemAddTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagClient) ProblemDeleteTags(ctx context.Context, in *ProblemDeleteTagsReq, opts ...grpc.CallOption) (*ProblemDeleteTagsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProblemDeleteTagsResp)
	err := c.cc.Invoke(ctx, Tag_ProblemDeleteTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagClient) GetProblemTags(ctx context.Context, in *GetProblemTagsReq, opts ...grpc.CallOption) (*GetProblemTagsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProblemTagsResp)
	err := c.cc.Invoke(ctx, Tag_GetProblemTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TagServer is the server API for Tag service.
// All implementations must embed UnimplementedTagServer
// for forward compatibility
//
// 标签
type TagServer interface {
	// 添加标签，客服权限
	AddTags(context.Context, *AddTagsReq) (*AddTagsResp, error)
	// 删除标签，客服权限
	DeleteTags(context.Context, *DeleteTagsReq) (*DeleteTagsResp, error)
	// 强行删除标签，管理员权限
	MustDeleteTags(context.Context, *MustDeleteTagsReq) (*MustDeleteTagsResp, error)
	// 更新标签，客服权限
	UpdateTags(context.Context, *UpdateTagsReq) (*UpdateTagsResp, error)
	// 获取所有标签，可缓存
	GetAllTags(context.Context, *GetAllTagsReq) (*GetAllTagsResp, error)
	// 给题目添加标签，最多5个，客服权限
	ProblemAddTags(context.Context, *ProblemAddTagsReq) (*ProblemAddTagsResp, error)
	// 给题目删除标签，客服权限
	ProblemDeleteTags(context.Context, *ProblemDeleteTagsReq) (*ProblemDeleteTagsResp, error)
	// 获取一个题目的所有标签，可缓存
	GetProblemTags(context.Context, *GetProblemTagsReq) (*GetProblemTagsResp, error)
	mustEmbedUnimplementedTagServer()
}

// UnimplementedTagServer must be embedded to have forward compatible implementations.
type UnimplementedTagServer struct {
}

func (UnimplementedTagServer) AddTags(context.Context, *AddTagsReq) (*AddTagsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddTags not implemented")
}
func (UnimplementedTagServer) DeleteTags(context.Context, *DeleteTagsReq) (*DeleteTagsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTags not implemented")
}
func (UnimplementedTagServer) MustDeleteTags(context.Context, *MustDeleteTagsReq) (*MustDeleteTagsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MustDeleteTags not implemented")
}
func (UnimplementedTagServer) UpdateTags(context.Context, *UpdateTagsReq) (*UpdateTagsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTags not implemented")
}
func (UnimplementedTagServer) GetAllTags(context.Context, *GetAllTagsReq) (*GetAllTagsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllTags not implemented")
}
func (UnimplementedTagServer) ProblemAddTags(context.Context, *ProblemAddTagsReq) (*ProblemAddTagsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProblemAddTags not implemented")
}
func (UnimplementedTagServer) ProblemDeleteTags(context.Context, *ProblemDeleteTagsReq) (*ProblemDeleteTagsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProblemDeleteTags not implemented")
}
func (UnimplementedTagServer) GetProblemTags(context.Context, *GetProblemTagsReq) (*GetProblemTagsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProblemTags not implemented")
}
func (UnimplementedTagServer) mustEmbedUnimplementedTagServer() {}

// UnsafeTagServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TagServer will
// result in compilation errors.
type UnsafeTagServer interface {
	mustEmbedUnimplementedTagServer()
}

func RegisterTagServer(s grpc.ServiceRegistrar, srv TagServer) {
	s.RegisterService(&Tag_ServiceDesc, srv)
}

func _Tag_AddTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddTagsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServer).AddTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tag_AddTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServer).AddTags(ctx, req.(*AddTagsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tag_DeleteTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTagsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServer).DeleteTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tag_DeleteTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServer).DeleteTags(ctx, req.(*DeleteTagsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tag_MustDeleteTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MustDeleteTagsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServer).MustDeleteTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tag_MustDeleteTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServer).MustDeleteTags(ctx, req.(*MustDeleteTagsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tag_UpdateTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTagsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServer).UpdateTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tag_UpdateTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServer).UpdateTags(ctx, req.(*UpdateTagsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tag_GetAllTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllTagsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServer).GetAllTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tag_GetAllTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServer).GetAllTags(ctx, req.(*GetAllTagsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tag_ProblemAddTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProblemAddTagsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServer).ProblemAddTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tag_ProblemAddTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServer).ProblemAddTags(ctx, req.(*ProblemAddTagsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tag_ProblemDeleteTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProblemDeleteTagsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServer).ProblemDeleteTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tag_ProblemDeleteTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServer).ProblemDeleteTags(ctx, req.(*ProblemDeleteTagsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tag_GetProblemTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProblemTagsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServer).GetProblemTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tag_GetProblemTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServer).GetProblemTags(ctx, req.(*GetProblemTagsReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Tag_ServiceDesc is the grpc.ServiceDesc for Tag service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Tag_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "problemset.Tag",
	HandlerType: (*TagServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddTags",
			Handler:    _Tag_AddTags_Handler,
		},
		{
			MethodName: "DeleteTags",
			Handler:    _Tag_DeleteTags_Handler,
		},
		{
			MethodName: "MustDeleteTags",
			Handler:    _Tag_MustDeleteTags_Handler,
		},
		{
			MethodName: "UpdateTags",
			Handler:    _Tag_UpdateTags_Handler,
		},
		{
			MethodName: "GetAllTags",
			Handler:    _Tag_GetAllTags_Handler,
		},
		{
			MethodName: "ProblemAddTags",
			Handler:    _Tag_ProblemAddTags_Handler,
		},
		{
			MethodName: "ProblemDeleteTags",
			Handler:    _Tag_ProblemDeleteTags_Handler,
		},
		{
			MethodName: "GetProblemTags",
			Handler:    _Tag_GetProblemTags_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "problemset.proto",
}

const (
	Example_AddExample_FullMethodName         = "/problemset.Example/AddExample"
	Example_DeleteExample_FullMethodName      = "/problemset.Example/DeleteExample"
	Example_UpdateExample_FullMethodName      = "/problemset.Example/UpdateExample"
	Example_GetExample_FullMethodName         = "/problemset.Example/GetExample"
	Example_GetProblemExamples_FullMethodName = "/problemset.Example/GetProblemExamples"
)

// ExampleClient is the client API for Example service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 样例
type ExampleClient interface {
	// 添加样例，客服权限
	AddExample(ctx context.Context, in *AddExampleReq, opts ...grpc.CallOption) (*AddExampleResp, error)
	// 删除样例，客服权限
	DeleteExample(ctx context.Context, in *DeleteExampleReq, opts ...grpc.CallOption) (*DeleteExampleResp, error)
	// 修改样例，客服权限
	UpdateExample(ctx context.Context, in *UpdateExampleReq, opts ...grpc.CallOption) (*UpdateExampleResp, error)
	// 获取样例
	GetExample(ctx context.Context, in *GetExampleReq, opts ...grpc.CallOption) (*GetExampleResp, error)
	// 获取题目的所有样例
	GetProblemExamples(ctx context.Context, in *GetProblemExamplesReq, opts ...grpc.CallOption) (*GetProblemExamplesResp, error)
}

type exampleClient struct {
	cc grpc.ClientConnInterface
}

func NewExampleClient(cc grpc.ClientConnInterface) ExampleClient {
	return &exampleClient{cc}
}

func (c *exampleClient) AddExample(ctx context.Context, in *AddExampleReq, opts ...grpc.CallOption) (*AddExampleResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddExampleResp)
	err := c.cc.Invoke(ctx, Example_AddExample_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exampleClient) DeleteExample(ctx context.Context, in *DeleteExampleReq, opts ...grpc.CallOption) (*DeleteExampleResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteExampleResp)
	err := c.cc.Invoke(ctx, Example_DeleteExample_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exampleClient) UpdateExample(ctx context.Context, in *UpdateExampleReq, opts ...grpc.CallOption) (*UpdateExampleResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateExampleResp)
	err := c.cc.Invoke(ctx, Example_UpdateExample_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exampleClient) GetExample(ctx context.Context, in *GetExampleReq, opts ...grpc.CallOption) (*GetExampleResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetExampleResp)
	err := c.cc.Invoke(ctx, Example_GetExample_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exampleClient) GetProblemExamples(ctx context.Context, in *GetProblemExamplesReq, opts ...grpc.CallOption) (*GetProblemExamplesResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProblemExamplesResp)
	err := c.cc.Invoke(ctx, Example_GetProblemExamples_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ExampleServer is the server API for Example service.
// All implementations must embed UnimplementedExampleServer
// for forward compatibility
//
// 样例
type ExampleServer interface {
	// 添加样例，客服权限
	AddExample(context.Context, *AddExampleReq) (*AddExampleResp, error)
	// 删除样例，客服权限
	DeleteExample(context.Context, *DeleteExampleReq) (*DeleteExampleResp, error)
	// 修改样例，客服权限
	UpdateExample(context.Context, *UpdateExampleReq) (*UpdateExampleResp, error)
	// 获取样例
	GetExample(context.Context, *GetExampleReq) (*GetExampleResp, error)
	// 获取题目的所有样例
	GetProblemExamples(context.Context, *GetProblemExamplesReq) (*GetProblemExamplesResp, error)
	mustEmbedUnimplementedExampleServer()
}

// UnimplementedExampleServer must be embedded to have forward compatible implementations.
type UnimplementedExampleServer struct {
}

func (UnimplementedExampleServer) AddExample(context.Context, *AddExampleReq) (*AddExampleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddExample not implemented")
}
func (UnimplementedExampleServer) DeleteExample(context.Context, *DeleteExampleReq) (*DeleteExampleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteExample not implemented")
}
func (UnimplementedExampleServer) UpdateExample(context.Context, *UpdateExampleReq) (*UpdateExampleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateExample not implemented")
}
func (UnimplementedExampleServer) GetExample(context.Context, *GetExampleReq) (*GetExampleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExample not implemented")
}
func (UnimplementedExampleServer) GetProblemExamples(context.Context, *GetProblemExamplesReq) (*GetProblemExamplesResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProblemExamples not implemented")
}
func (UnimplementedExampleServer) mustEmbedUnimplementedExampleServer() {}

// UnsafeExampleServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ExampleServer will
// result in compilation errors.
type UnsafeExampleServer interface {
	mustEmbedUnimplementedExampleServer()
}

func RegisterExampleServer(s grpc.ServiceRegistrar, srv ExampleServer) {
	s.RegisterService(&Example_ServiceDesc, srv)
}

func _Example_AddExample_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddExampleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExampleServer).AddExample(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Example_AddExample_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExampleServer).AddExample(ctx, req.(*AddExampleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Example_DeleteExample_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteExampleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExampleServer).DeleteExample(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Example_DeleteExample_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExampleServer).DeleteExample(ctx, req.(*DeleteExampleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Example_UpdateExample_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateExampleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExampleServer).UpdateExample(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Example_UpdateExample_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExampleServer).UpdateExample(ctx, req.(*UpdateExampleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Example_GetExample_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExampleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExampleServer).GetExample(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Example_GetExample_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExampleServer).GetExample(ctx, req.(*GetExampleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Example_GetProblemExamples_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProblemExamplesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExampleServer).GetProblemExamples(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Example_GetProblemExamples_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExampleServer).GetProblemExamples(ctx, req.(*GetProblemExamplesReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Example_ServiceDesc is the grpc.ServiceDesc for Example service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Example_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "problemset.Example",
	HandlerType: (*ExampleServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddExample",
			Handler:    _Example_AddExample_Handler,
		},
		{
			MethodName: "DeleteExample",
			Handler:    _Example_DeleteExample_Handler,
		},
		{
			MethodName: "UpdateExample",
			Handler:    _Example_UpdateExample_Handler,
		},
		{
			MethodName: "GetExample",
			Handler:    _Example_GetExample_Handler,
		},
		{
			MethodName: "GetProblemExamples",
			Handler:    _Example_GetProblemExamples_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "problemset.proto",
}

const (
	Hint_AddHint_FullMethodName         = "/problemset.Hint/AddHint"
	Hint_DeleteHint_FullMethodName      = "/problemset.Hint/DeleteHint"
	Hint_UpdateHint_FullMethodName      = "/problemset.Hint/UpdateHint"
	Hint_GetHint_FullMethodName         = "/problemset.Hint/GetHint"
	Hint_GetProblemHints_FullMethodName = "/problemset.Hint/GetProblemHints"
)

// HintClient is the client API for Hint service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 提示
type HintClient interface {
	// 添加提示，客服权限
	AddHint(ctx context.Context, in *AddHintReq, opts ...grpc.CallOption) (*AddHintResp, error)
	// 删除提示，客服权限
	DeleteHint(ctx context.Context, in *DeleteHintReq, opts ...grpc.CallOption) (*DeleteHintResp, error)
	// 修改提示，客服权限
	UpdateHint(ctx context.Context, in *UpdateHintReq, opts ...grpc.CallOption) (*UpdateHintResp, error)
	// 获取提示
	GetHint(ctx context.Context, in *GetHintReq, opts ...grpc.CallOption) (*GetHintResp, error)
	// 获取题目所有提示
	GetProblemHints(ctx context.Context, in *GetProblemHintsReq, opts ...grpc.CallOption) (*GetProblemHintsResp, error)
}

type hintClient struct {
	cc grpc.ClientConnInterface
}

func NewHintClient(cc grpc.ClientConnInterface) HintClient {
	return &hintClient{cc}
}

func (c *hintClient) AddHint(ctx context.Context, in *AddHintReq, opts ...grpc.CallOption) (*AddHintResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddHintResp)
	err := c.cc.Invoke(ctx, Hint_AddHint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hintClient) DeleteHint(ctx context.Context, in *DeleteHintReq, opts ...grpc.CallOption) (*DeleteHintResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteHintResp)
	err := c.cc.Invoke(ctx, Hint_DeleteHint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hintClient) UpdateHint(ctx context.Context, in *UpdateHintReq, opts ...grpc.CallOption) (*UpdateHintResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateHintResp)
	err := c.cc.Invoke(ctx, Hint_UpdateHint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hintClient) GetHint(ctx context.Context, in *GetHintReq, opts ...grpc.CallOption) (*GetHintResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetHintResp)
	err := c.cc.Invoke(ctx, Hint_GetHint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hintClient) GetProblemHints(ctx context.Context, in *GetProblemHintsReq, opts ...grpc.CallOption) (*GetProblemHintsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProblemHintsResp)
	err := c.cc.Invoke(ctx, Hint_GetProblemHints_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HintServer is the server API for Hint service.
// All implementations must embed UnimplementedHintServer
// for forward compatibility
//
// 提示
type HintServer interface {
	// 添加提示，客服权限
	AddHint(context.Context, *AddHintReq) (*AddHintResp, error)
	// 删除提示，客服权限
	DeleteHint(context.Context, *DeleteHintReq) (*DeleteHintResp, error)
	// 修改提示，客服权限
	UpdateHint(context.Context, *UpdateHintReq) (*UpdateHintResp, error)
	// 获取提示
	GetHint(context.Context, *GetHintReq) (*GetHintResp, error)
	// 获取题目所有提示
	GetProblemHints(context.Context, *GetProblemHintsReq) (*GetProblemHintsResp, error)
	mustEmbedUnimplementedHintServer()
}

// UnimplementedHintServer must be embedded to have forward compatible implementations.
type UnimplementedHintServer struct {
}

func (UnimplementedHintServer) AddHint(context.Context, *AddHintReq) (*AddHintResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddHint not implemented")
}
func (UnimplementedHintServer) DeleteHint(context.Context, *DeleteHintReq) (*DeleteHintResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteHint not implemented")
}
func (UnimplementedHintServer) UpdateHint(context.Context, *UpdateHintReq) (*UpdateHintResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateHint not implemented")
}
func (UnimplementedHintServer) GetHint(context.Context, *GetHintReq) (*GetHintResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHint not implemented")
}
func (UnimplementedHintServer) GetProblemHints(context.Context, *GetProblemHintsReq) (*GetProblemHintsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProblemHints not implemented")
}
func (UnimplementedHintServer) mustEmbedUnimplementedHintServer() {}

// UnsafeHintServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HintServer will
// result in compilation errors.
type UnsafeHintServer interface {
	mustEmbedUnimplementedHintServer()
}

func RegisterHintServer(s grpc.ServiceRegistrar, srv HintServer) {
	s.RegisterService(&Hint_ServiceDesc, srv)
}

func _Hint_AddHint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddHintReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HintServer).AddHint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hint_AddHint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HintServer).AddHint(ctx, req.(*AddHintReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hint_DeleteHint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteHintReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HintServer).DeleteHint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hint_DeleteHint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HintServer).DeleteHint(ctx, req.(*DeleteHintReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hint_UpdateHint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateHintReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HintServer).UpdateHint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hint_UpdateHint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HintServer).UpdateHint(ctx, req.(*UpdateHintReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hint_GetHint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHintReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HintServer).GetHint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hint_GetHint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HintServer).GetHint(ctx, req.(*GetHintReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hint_GetProblemHints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProblemHintsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HintServer).GetProblemHints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hint_GetProblemHints_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HintServer).GetProblemHints(ctx, req.(*GetProblemHintsReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Hint_ServiceDesc is the grpc.ServiceDesc for Hint service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Hint_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "problemset.Hint",
	HandlerType: (*HintServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddHint",
			Handler:    _Hint_AddHint_Handler,
		},
		{
			MethodName: "DeleteHint",
			Handler:    _Hint_DeleteHint_Handler,
		},
		{
			MethodName: "UpdateHint",
			Handler:    _Hint_UpdateHint_Handler,
		},
		{
			MethodName: "GetHint",
			Handler:    _Hint_GetHint_Handler,
		},
		{
			MethodName: "GetProblemHints",
			Handler:    _Hint_GetProblemHints_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "problemset.proto",
}

const (
	JudgeData_AddJudgeData_FullMethodName    = "/problemset.JudgeData/AddJudgeData"
	JudgeData_DeleteJudgeData_FullMethodName = "/problemset.JudgeData/DeleteJudgeData"
	JudgeData_UpdateJudgeData_FullMethodName = "/problemset.JudgeData/UpdateJudgeData"
	JudgeData_GetJudgeData_FullMethodName    = "/problemset.JudgeData/GetJudgeData"
)

// JudgeDataClient is the client API for JudgeData service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 评测数据
type JudgeDataClient interface {
	// 添加测评数据，客服权限
	AddJudgeData(ctx context.Context, in *AddJudgeDataReq, opts ...grpc.CallOption) (*AddJudgeDataResp, error)
	// 删除测评数据，客服权限
	DeleteJudgeData(ctx context.Context, in *DeleteJudgeDataReq, opts ...grpc.CallOption) (*DeleteJudgeDataResp, error)
	// 修改测评数据，客服权限
	UpdateJudgeData(ctx context.Context, in *UpdateJudgeDataReq, opts ...grpc.CallOption) (*UpdateJudgeDataResp, error)
	// 获取题目的测评数据，返回minio对象名称，可缓存
	GetJudgeData(ctx context.Context, in *GetJudgeDataReq, opts ...grpc.CallOption) (*GetJudgeDataResp, error)
}

type judgeDataClient struct {
	cc grpc.ClientConnInterface
}

func NewJudgeDataClient(cc grpc.ClientConnInterface) JudgeDataClient {
	return &judgeDataClient{cc}
}

func (c *judgeDataClient) AddJudgeData(ctx context.Context, in *AddJudgeDataReq, opts ...grpc.CallOption) (*AddJudgeDataResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddJudgeDataResp)
	err := c.cc.Invoke(ctx, JudgeData_AddJudgeData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeDataClient) DeleteJudgeData(ctx context.Context, in *DeleteJudgeDataReq, opts ...grpc.CallOption) (*DeleteJudgeDataResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteJudgeDataResp)
	err := c.cc.Invoke(ctx, JudgeData_DeleteJudgeData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeDataClient) UpdateJudgeData(ctx context.Context, in *UpdateJudgeDataReq, opts ...grpc.CallOption) (*UpdateJudgeDataResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateJudgeDataResp)
	err := c.cc.Invoke(ctx, JudgeData_UpdateJudgeData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeDataClient) GetJudgeData(ctx context.Context, in *GetJudgeDataReq, opts ...grpc.CallOption) (*GetJudgeDataResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetJudgeDataResp)
	err := c.cc.Invoke(ctx, JudgeData_GetJudgeData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// JudgeDataServer is the server API for JudgeData service.
// All implementations must embed UnimplementedJudgeDataServer
// for forward compatibility
//
// 评测数据
type JudgeDataServer interface {
	// 添加测评数据，客服权限
	AddJudgeData(context.Context, *AddJudgeDataReq) (*AddJudgeDataResp, error)
	// 删除测评数据，客服权限
	DeleteJudgeData(context.Context, *DeleteJudgeDataReq) (*DeleteJudgeDataResp, error)
	// 修改测评数据，客服权限
	UpdateJudgeData(context.Context, *UpdateJudgeDataReq) (*UpdateJudgeDataResp, error)
	// 获取题目的测评数据，返回minio对象名称，可缓存
	GetJudgeData(context.Context, *GetJudgeDataReq) (*GetJudgeDataResp, error)
	mustEmbedUnimplementedJudgeDataServer()
}

// UnimplementedJudgeDataServer must be embedded to have forward compatible implementations.
type UnimplementedJudgeDataServer struct {
}

func (UnimplementedJudgeDataServer) AddJudgeData(context.Context, *AddJudgeDataReq) (*AddJudgeDataResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddJudgeData not implemented")
}
func (UnimplementedJudgeDataServer) DeleteJudgeData(context.Context, *DeleteJudgeDataReq) (*DeleteJudgeDataResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteJudgeData not implemented")
}
func (UnimplementedJudgeDataServer) UpdateJudgeData(context.Context, *UpdateJudgeDataReq) (*UpdateJudgeDataResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateJudgeData not implemented")
}
func (UnimplementedJudgeDataServer) GetJudgeData(context.Context, *GetJudgeDataReq) (*GetJudgeDataResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetJudgeData not implemented")
}
func (UnimplementedJudgeDataServer) mustEmbedUnimplementedJudgeDataServer() {}

// UnsafeJudgeDataServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to JudgeDataServer will
// result in compilation errors.
type UnsafeJudgeDataServer interface {
	mustEmbedUnimplementedJudgeDataServer()
}

func RegisterJudgeDataServer(s grpc.ServiceRegistrar, srv JudgeDataServer) {
	s.RegisterService(&JudgeData_ServiceDesc, srv)
}

func _JudgeData_AddJudgeData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddJudgeDataReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeDataServer).AddJudgeData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JudgeData_AddJudgeData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeDataServer).AddJudgeData(ctx, req.(*AddJudgeDataReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _JudgeData_DeleteJudgeData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteJudgeDataReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeDataServer).DeleteJudgeData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JudgeData_DeleteJudgeData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeDataServer).DeleteJudgeData(ctx, req.(*DeleteJudgeDataReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _JudgeData_UpdateJudgeData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateJudgeDataReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeDataServer).UpdateJudgeData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JudgeData_UpdateJudgeData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeDataServer).UpdateJudgeData(ctx, req.(*UpdateJudgeDataReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _JudgeData_GetJudgeData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetJudgeDataReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeDataServer).GetJudgeData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JudgeData_GetJudgeData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeDataServer).GetJudgeData(ctx, req.(*GetJudgeDataReq))
	}
	return interceptor(ctx, in, info, handler)
}

// JudgeData_ServiceDesc is the grpc.ServiceDesc for JudgeData service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var JudgeData_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "problemset.JudgeData",
	HandlerType: (*JudgeDataServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddJudgeData",
			Handler:    _JudgeData_AddJudgeData_Handler,
		},
		{
			MethodName: "DeleteJudgeData",
			Handler:    _JudgeData_DeleteJudgeData_Handler,
		},
		{
			MethodName: "UpdateJudgeData",
			Handler:    _JudgeData_UpdateJudgeData_Handler,
		},
		{
			MethodName: "GetJudgeData",
			Handler:    _JudgeData_GetJudgeData_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "problemset.proto",
}

const (
	Language_AddLanguage_FullMethodName    = "/problemset.Language/AddLanguage"
	Language_DeleteLanguage_FullMethodName = "/problemset.Language/DeleteLanguage"
	Language_UpdateLanguage_FullMethodName = "/problemset.Language/UpdateLanguage"
	Language_GetLanguage_FullMethodName    = "/problemset.Language/GetLanguage"
)

// LanguageClient is the client API for Language service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 编程语言
type LanguageClient interface {
	// 添加语言，客服权限
	AddLanguage(ctx context.Context, in *AddLanguageReq, opts ...grpc.CallOption) (*AddLanguageResp, error)
	// 删除语言，客服权限
	DeleteLanguage(ctx context.Context, in *DeleteLanguageReq, opts ...grpc.CallOption) (*DeleteLanguageResp, error)
	// 更新语言，客服权限
	UpdateLanguage(ctx context.Context, in *UpdateLanguageReq, opts ...grpc.CallOption) (*UpdateLanguageResp, error)
	// 获取所有语言
	GetLanguage(ctx context.Context, in *GetLanguageReq, opts ...grpc.CallOption) (*GetLanguageResp, error)
}

type languageClient struct {
	cc grpc.ClientConnInterface
}

func NewLanguageClient(cc grpc.ClientConnInterface) LanguageClient {
	return &languageClient{cc}
}

func (c *languageClient) AddLanguage(ctx context.Context, in *AddLanguageReq, opts ...grpc.CallOption) (*AddLanguageResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddLanguageResp)
	err := c.cc.Invoke(ctx, Language_AddLanguage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageClient) DeleteLanguage(ctx context.Context, in *DeleteLanguageReq, opts ...grpc.CallOption) (*DeleteLanguageResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteLanguageResp)
	err := c.cc.Invoke(ctx, Language_DeleteLanguage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageClient) UpdateLanguage(ctx context.Context, in *UpdateLanguageReq, opts ...grpc.CallOption) (*UpdateLanguageResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateLanguageResp)
	err := c.cc.Invoke(ctx, Language_UpdateLanguage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageClient) GetLanguage(ctx context.Context, in *GetLanguageReq, opts ...grpc.CallOption) (*GetLanguageResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLanguageResp)
	err := c.cc.Invoke(ctx, Language_GetLanguage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LanguageServer is the server API for Language service.
// All implementations must embed UnimplementedLanguageServer
// for forward compatibility
//
// 编程语言
type LanguageServer interface {
	// 添加语言，客服权限
	AddLanguage(context.Context, *AddLanguageReq) (*AddLanguageResp, error)
	// 删除语言，客服权限
	DeleteLanguage(context.Context, *DeleteLanguageReq) (*DeleteLanguageResp, error)
	// 更新语言，客服权限
	UpdateLanguage(context.Context, *UpdateLanguageReq) (*UpdateLanguageResp, error)
	// 获取所有语言
	GetLanguage(context.Context, *GetLanguageReq) (*GetLanguageResp, error)
	mustEmbedUnimplementedLanguageServer()
}

// UnimplementedLanguageServer must be embedded to have forward compatible implementations.
type UnimplementedLanguageServer struct {
}

func (UnimplementedLanguageServer) AddLanguage(context.Context, *AddLanguageReq) (*AddLanguageResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddLanguage not implemented")
}
func (UnimplementedLanguageServer) DeleteLanguage(context.Context, *DeleteLanguageReq) (*DeleteLanguageResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteLanguage not implemented")
}
func (UnimplementedLanguageServer) UpdateLanguage(context.Context, *UpdateLanguageReq) (*UpdateLanguageResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateLanguage not implemented")
}
func (UnimplementedLanguageServer) GetLanguage(context.Context, *GetLanguageReq) (*GetLanguageResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLanguage not implemented")
}
func (UnimplementedLanguageServer) mustEmbedUnimplementedLanguageServer() {}

// UnsafeLanguageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LanguageServer will
// result in compilation errors.
type UnsafeLanguageServer interface {
	mustEmbedUnimplementedLanguageServer()
}

func RegisterLanguageServer(s grpc.ServiceRegistrar, srv LanguageServer) {
	s.RegisterService(&Language_ServiceDesc, srv)
}

func _Language_AddLanguage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddLanguageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServer).AddLanguage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Language_AddLanguage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServer).AddLanguage(ctx, req.(*AddLanguageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Language_DeleteLanguage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteLanguageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServer).DeleteLanguage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Language_DeleteLanguage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServer).DeleteLanguage(ctx, req.(*DeleteLanguageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Language_UpdateLanguage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateLanguageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServer).UpdateLanguage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Language_UpdateLanguage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServer).UpdateLanguage(ctx, req.(*UpdateLanguageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Language_GetLanguage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLanguageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServer).GetLanguage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Language_GetLanguage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServer).GetLanguage(ctx, req.(*GetLanguageReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Language_ServiceDesc is the grpc.ServiceDesc for Language service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Language_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "problemset.Language",
	HandlerType: (*LanguageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddLanguage",
			Handler:    _Language_AddLanguage_Handler,
		},
		{
			MethodName: "DeleteLanguage",
			Handler:    _Language_DeleteLanguage_Handler,
		},
		{
			MethodName: "UpdateLanguage",
			Handler:    _Language_UpdateLanguage_Handler,
		},
		{
			MethodName: "GetLanguage",
			Handler:    _Language_GetLanguage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "problemset.proto",
}

const (
	Submit_SubmitCode_FullMethodName            = "/problemset.Submit/SubmitCode"
	Submit_GetProblemSubmitCount_FullMethodName = "/problemset.Submit/GetProblemSubmitCount"
	Submit_GetUserSubmit_FullMethodName         = "/problemset.Submit/GetUserSubmit"
	Submit_GetUserProblemSubmit_FullMethodName  = "/problemset.Submit/GetUserProblemSubmit"
	Submit_GetSubmitById_FullMethodName         = "/problemset.Submit/GetSubmitById"
)

// SubmitClient is the client API for Submit service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 提交
type SubmitClient interface {
	// 用户提交代码
	SubmitCode(ctx context.Context, in *SubmitCodeReq, opts ...grpc.CallOption) (*SubmitCodeResp, error)
	// 获取题目的提交数
	GetProblemSubmitCount(ctx context.Context, in *GetProblemSubmitCountReq, opts ...grpc.CallOption) (*GetProblemSubmitCountResp, error)
	// 分页获取用户提交
	GetUserSubmit(ctx context.Context, in *GetUserSubmitReq, opts ...grpc.CallOption) (*GetUserSubmitResp, error)
	// 获取用户某一道题的全部提交
	GetUserProblemSubmit(ctx context.Context, in *GetUserProblemSubmitReq, opts ...grpc.CallOption) (*GetUserProblemSubmitResp, error)
	// 获取通过id提交记录
	GetSubmitById(ctx context.Context, in *GetSubmitByIdReq, opts ...grpc.CallOption) (*GetSubmitByIdResp, error)
}

type submitClient struct {
	cc grpc.ClientConnInterface
}

func NewSubmitClient(cc grpc.ClientConnInterface) SubmitClient {
	return &submitClient{cc}
}

func (c *submitClient) SubmitCode(ctx context.Context, in *SubmitCodeReq, opts ...grpc.CallOption) (*SubmitCodeResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitCodeResp)
	err := c.cc.Invoke(ctx, Submit_SubmitCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *submitClient) GetProblemSubmitCount(ctx context.Context, in *GetProblemSubmitCountReq, opts ...grpc.CallOption) (*GetProblemSubmitCountResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProblemSubmitCountResp)
	err := c.cc.Invoke(ctx, Submit_GetProblemSubmitCount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *submitClient) GetUserSubmit(ctx context.Context, in *GetUserSubmitReq, opts ...grpc.CallOption) (*GetUserSubmitResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserSubmitResp)
	err := c.cc.Invoke(ctx, Submit_GetUserSubmit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *submitClient) GetUserProblemSubmit(ctx context.Context, in *GetUserProblemSubmitReq, opts ...grpc.CallOption) (*GetUserProblemSubmitResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserProblemSubmitResp)
	err := c.cc.Invoke(ctx, Submit_GetUserProblemSubmit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *submitClient) GetSubmitById(ctx context.Context, in *GetSubmitByIdReq, opts ...grpc.CallOption) (*GetSubmitByIdResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSubmitByIdResp)
	err := c.cc.Invoke(ctx, Submit_GetSubmitById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SubmitServer is the server API for Submit service.
// All implementations must embed UnimplementedSubmitServer
// for forward compatibility
//
// 提交
type SubmitServer interface {
	// 用户提交代码
	SubmitCode(context.Context, *SubmitCodeReq) (*SubmitCodeResp, error)
	// 获取题目的提交数
	GetProblemSubmitCount(context.Context, *GetProblemSubmitCountReq) (*GetProblemSubmitCountResp, error)
	// 分页获取用户提交
	GetUserSubmit(context.Context, *GetUserSubmitReq) (*GetUserSubmitResp, error)
	// 获取用户某一道题的全部提交
	GetUserProblemSubmit(context.Context, *GetUserProblemSubmitReq) (*GetUserProblemSubmitResp, error)
	// 获取通过id提交记录
	GetSubmitById(context.Context, *GetSubmitByIdReq) (*GetSubmitByIdResp, error)
	mustEmbedUnimplementedSubmitServer()
}

// UnimplementedSubmitServer must be embedded to have forward compatible implementations.
type UnimplementedSubmitServer struct {
}

func (UnimplementedSubmitServer) SubmitCode(context.Context, *SubmitCodeReq) (*SubmitCodeResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitCode not implemented")
}
func (UnimplementedSubmitServer) GetProblemSubmitCount(context.Context, *GetProblemSubmitCountReq) (*GetProblemSubmitCountResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProblemSubmitCount not implemented")
}
func (UnimplementedSubmitServer) GetUserSubmit(context.Context, *GetUserSubmitReq) (*GetUserSubmitResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserSubmit not implemented")
}
func (UnimplementedSubmitServer) GetUserProblemSubmit(context.Context, *GetUserProblemSubmitReq) (*GetUserProblemSubmitResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserProblemSubmit not implemented")
}
func (UnimplementedSubmitServer) GetSubmitById(context.Context, *GetSubmitByIdReq) (*GetSubmitByIdResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSubmitById not implemented")
}
func (UnimplementedSubmitServer) mustEmbedUnimplementedSubmitServer() {}

// UnsafeSubmitServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SubmitServer will
// result in compilation errors.
type UnsafeSubmitServer interface {
	mustEmbedUnimplementedSubmitServer()
}

func RegisterSubmitServer(s grpc.ServiceRegistrar, srv SubmitServer) {
	s.RegisterService(&Submit_ServiceDesc, srv)
}

func _Submit_SubmitCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitCodeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubmitServer).SubmitCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Submit_SubmitCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubmitServer).SubmitCode(ctx, req.(*SubmitCodeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Submit_GetProblemSubmitCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProblemSubmitCountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubmitServer).GetProblemSubmitCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Submit_GetProblemSubmitCount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubmitServer).GetProblemSubmitCount(ctx, req.(*GetProblemSubmitCountReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Submit_GetUserSubmit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserSubmitReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubmitServer).GetUserSubmit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Submit_GetUserSubmit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubmitServer).GetUserSubmit(ctx, req.(*GetUserSubmitReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Submit_GetUserProblemSubmit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserProblemSubmitReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubmitServer).GetUserProblemSubmit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Submit_GetUserProblemSubmit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubmitServer).GetUserProblemSubmit(ctx, req.(*GetUserProblemSubmitReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Submit_GetSubmitById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSubmitByIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubmitServer).GetSubmitById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Submit_GetSubmitById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubmitServer).GetSubmitById(ctx, req.(*GetSubmitByIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Submit_ServiceDesc is the grpc.ServiceDesc for Submit service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Submit_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "problemset.Submit",
	HandlerType: (*SubmitServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SubmitCode",
			Handler:    _Submit_SubmitCode_Handler,
		},
		{
			MethodName: "GetProblemSubmitCount",
			Handler:    _Submit_GetProblemSubmitCount_Handler,
		},
		{
			MethodName: "GetUserSubmit",
			Handler:    _Submit_GetUserSubmit_Handler,
		},
		{
			MethodName: "GetUserProblemSubmit",
			Handler:    _Submit_GetUserProblemSubmit_Handler,
		},
		{
			MethodName: "GetSubmitById",
			Handler:    _Submit_GetSubmitById_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "problemset.proto",
}
