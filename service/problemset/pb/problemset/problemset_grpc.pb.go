// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v3.21.12
// source: problemset.proto

package problemset

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
	Problem_AddProblem_FullMethodName        = "/problemset.Problem/AddProblem"
	Problem_DeleteProblem_FullMethodName     = "/problemset.Problem/DeleteProblem"
	Problem_GetProblemContent_FullMethodName = "/problemset.Problem/GetProblemContent"
	Problem_UpdateProblem_FullMethodName     = "/problemset.Problem/UpdateProblem"
	Problem_SearchProblem_FullMethodName     = "/problemset.Problem/SearchProblem"
)

// ProblemClient is the client API for Problem service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 题目
type ProblemClient interface {
	// 添加问题
	AddProblem(ctx context.Context, opts ...grpc.CallOption) (Problem_AddProblemClient, error)
	// 删除问题
	DeleteProblem(ctx context.Context, in *DeleteProblemReq, opts ...grpc.CallOption) (*DeleteProblemResp, error)
	// 获取问题信息，可缓存
	GetProblemContent(ctx context.Context, in *GetProblemContentReq, opts ...grpc.CallOption) (Problem_GetProblemContentClient, error)
	// 更新问题
	UpdateProblem(ctx context.Context, opts ...grpc.CallOption) (Problem_UpdateProblemClient, error)
	// 分页搜索题目
	SearchProblem(ctx context.Context, in *SearchProblemReq, opts ...grpc.CallOption) (*SearchProblemResp, error)
}

type problemClient struct {
	cc grpc.ClientConnInterface
}

func NewProblemClient(cc grpc.ClientConnInterface) ProblemClient {
	return &problemClient{cc}
}

func (c *problemClient) AddProblem(ctx context.Context, opts ...grpc.CallOption) (Problem_AddProblemClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Problem_ServiceDesc.Streams[0], Problem_AddProblem_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &problemAddProblemClient{ClientStream: stream}
	return x, nil
}

type Problem_AddProblemClient interface {
	Send(*AddProblemReq) error
	CloseAndRecv() (*AddProblemResp, error)
	grpc.ClientStream
}

type problemAddProblemClient struct {
	grpc.ClientStream
}

func (x *problemAddProblemClient) Send(m *AddProblemReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *problemAddProblemClient) CloseAndRecv() (*AddProblemResp, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(AddProblemResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *problemClient) DeleteProblem(ctx context.Context, in *DeleteProblemReq, opts ...grpc.CallOption) (*DeleteProblemResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteProblemResp)
	err := c.cc.Invoke(ctx, Problem_DeleteProblem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *problemClient) GetProblemContent(ctx context.Context, in *GetProblemContentReq, opts ...grpc.CallOption) (Problem_GetProblemContentClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Problem_ServiceDesc.Streams[1], Problem_GetProblemContent_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &problemGetProblemContentClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Problem_GetProblemContentClient interface {
	Recv() (*GetProblemContentResp, error)
	grpc.ClientStream
}

type problemGetProblemContentClient struct {
	grpc.ClientStream
}

func (x *problemGetProblemContentClient) Recv() (*GetProblemContentResp, error) {
	m := new(GetProblemContentResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *problemClient) UpdateProblem(ctx context.Context, opts ...grpc.CallOption) (Problem_UpdateProblemClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Problem_ServiceDesc.Streams[2], Problem_UpdateProblem_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &problemUpdateProblemClient{ClientStream: stream}
	return x, nil
}

type Problem_UpdateProblemClient interface {
	Send(*UpdateProblemReq) error
	CloseAndRecv() (*UpdateProblemResp, error)
	grpc.ClientStream
}

type problemUpdateProblemClient struct {
	grpc.ClientStream
}

func (x *problemUpdateProblemClient) Send(m *UpdateProblemReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *problemUpdateProblemClient) CloseAndRecv() (*UpdateProblemResp, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UpdateProblemResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *problemClient) SearchProblem(ctx context.Context, in *SearchProblemReq, opts ...grpc.CallOption) (*SearchProblemResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchProblemResp)
	err := c.cc.Invoke(ctx, Problem_SearchProblem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProblemServer is the server API for Problem service.
// All implementations must embed UnimplementedProblemServer
// for forward compatibility
//
// 题目
type ProblemServer interface {
	// 添加问题
	AddProblem(Problem_AddProblemServer) error
	// 删除问题
	DeleteProblem(context.Context, *DeleteProblemReq) (*DeleteProblemResp, error)
	// 获取问题信息，可缓存
	GetProblemContent(*GetProblemContentReq, Problem_GetProblemContentServer) error
	// 更新问题
	UpdateProblem(Problem_UpdateProblemServer) error
	// 分页搜索题目
	SearchProblem(context.Context, *SearchProblemReq) (*SearchProblemResp, error)
	mustEmbedUnimplementedProblemServer()
}

// UnimplementedProblemServer must be embedded to have forward compatible implementations.
type UnimplementedProblemServer struct {
}

func (UnimplementedProblemServer) AddProblem(Problem_AddProblemServer) error {
	return status.Errorf(codes.Unimplemented, "method AddProblem not implemented")
}
func (UnimplementedProblemServer) DeleteProblem(context.Context, *DeleteProblemReq) (*DeleteProblemResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteProblem not implemented")
}
func (UnimplementedProblemServer) GetProblemContent(*GetProblemContentReq, Problem_GetProblemContentServer) error {
	return status.Errorf(codes.Unimplemented, "method GetProblemContent not implemented")
}
func (UnimplementedProblemServer) UpdateProblem(Problem_UpdateProblemServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateProblem not implemented")
}
func (UnimplementedProblemServer) SearchProblem(context.Context, *SearchProblemReq) (*SearchProblemResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchProblem not implemented")
}
func (UnimplementedProblemServer) mustEmbedUnimplementedProblemServer() {}

// UnsafeProblemServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProblemServer will
// result in compilation errors.
type UnsafeProblemServer interface {
	mustEmbedUnimplementedProblemServer()
}

func RegisterProblemServer(s grpc.ServiceRegistrar, srv ProblemServer) {
	s.RegisterService(&Problem_ServiceDesc, srv)
}

func _Problem_AddProblem_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ProblemServer).AddProblem(&problemAddProblemServer{ServerStream: stream})
}

type Problem_AddProblemServer interface {
	SendAndClose(*AddProblemResp) error
	Recv() (*AddProblemReq, error)
	grpc.ServerStream
}

type problemAddProblemServer struct {
	grpc.ServerStream
}

func (x *problemAddProblemServer) SendAndClose(m *AddProblemResp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *problemAddProblemServer) Recv() (*AddProblemReq, error) {
	m := new(AddProblemReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Problem_DeleteProblem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteProblemReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProblemServer).DeleteProblem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Problem_DeleteProblem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProblemServer).DeleteProblem(ctx, req.(*DeleteProblemReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Problem_GetProblemContent_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetProblemContentReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ProblemServer).GetProblemContent(m, &problemGetProblemContentServer{ServerStream: stream})
}

type Problem_GetProblemContentServer interface {
	Send(*GetProblemContentResp) error
	grpc.ServerStream
}

type problemGetProblemContentServer struct {
	grpc.ServerStream
}

func (x *problemGetProblemContentServer) Send(m *GetProblemContentResp) error {
	return x.ServerStream.SendMsg(m)
}

func _Problem_UpdateProblem_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ProblemServer).UpdateProblem(&problemUpdateProblemServer{ServerStream: stream})
}

type Problem_UpdateProblemServer interface {
	SendAndClose(*UpdateProblemResp) error
	Recv() (*UpdateProblemReq, error)
	grpc.ServerStream
}

type problemUpdateProblemServer struct {
	grpc.ServerStream
}

func (x *problemUpdateProblemServer) SendAndClose(m *UpdateProblemResp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *problemUpdateProblemServer) Recv() (*UpdateProblemReq, error) {
	m := new(UpdateProblemReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Problem_SearchProblem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchProblemReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProblemServer).SearchProblem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Problem_SearchProblem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProblemServer).SearchProblem(ctx, req.(*SearchProblemReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Problem_ServiceDesc is the grpc.ServiceDesc for Problem service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Problem_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "problemset.Problem",
	HandlerType: (*ProblemServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DeleteProblem",
			Handler:    _Problem_DeleteProblem_Handler,
		},
		{
			MethodName: "SearchProblem",
			Handler:    _Problem_SearchProblem_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AddProblem",
			Handler:       _Problem_AddProblem_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "GetProblemContent",
			Handler:       _Problem_GetProblemContent_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "UpdateProblem",
			Handler:       _Problem_UpdateProblem_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "problemset.proto",
}

const (
	Tag_AddTags_FullMethodName           = "/problemset.Tag/AddTags"
	Tag_DeleteTags_FullMethodName        = "/problemset.Tag/DeleteTags"
	Tag_MustDeleteTags_FullMethodName    = "/problemset.Tag/MustDeleteTags"
	Tag_UpdateTags_FullMethodName        = "/problemset.Tag/UpdateTags"
	Tag_GetAllTags_FullMethodName        = "/problemset.Tag/GetAllTags"
	Tag_ProblemAddTags_FullMethodName    = "/problemset.Tag/ProblemAddTags"
	Tag_ProblemDeleteTags_FullMethodName = "/problemset.Tag/ProblemDeleteTags"
	Tag_GetProblemTags_FullMethodName    = "/problemset.Tag/GetProblemTags"
)

// TagClient is the client API for Tag service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 标签
type TagClient interface {
	// 添加标签
	AddTags(ctx context.Context, in *AddTagsReq, opts ...grpc.CallOption) (*AddTagsResp, error)
	// 删除标签
	DeleteTags(ctx context.Context, in *DeleteTagsReq, opts ...grpc.CallOption) (*DeleteTagsResp, error)
	// 强行删除标签
	MustDeleteTags(ctx context.Context, in *MustDeleteTagsReq, opts ...grpc.CallOption) (*MustDeleteTagsResp, error)
	// 更新标签
	UpdateTags(ctx context.Context, in *UpdateTagsReq, opts ...grpc.CallOption) (*UpdateTagsResp, error)
	// 获取所有标签，可缓存
	GetAllTags(ctx context.Context, in *GetAllTagsReq, opts ...grpc.CallOption) (*GetAllTagsResp, error)
	// 给题目添加标签，最多5个
	ProblemAddTags(ctx context.Context, in *ProblemAddTagsReq, opts ...grpc.CallOption) (*ProblemAddTagsResp, error)
	// 给题目删除标签
	ProblemDeleteTags(ctx context.Context, in *ProblemDeleteTagsReq, opts ...grpc.CallOption) (*ProblemDeleteTagsResp, error)
	// 获取一个题目的所有标签，可缓存
	GetProblemTags(ctx context.Context, in *GetProblemTagsReq, opts ...grpc.CallOption) (*GetProblemTagsResp, error)
}

type tagClient struct {
	cc grpc.ClientConnInterface
}

func NewTagClient(cc grpc.ClientConnInterface) TagClient {
	return &tagClient{cc}
}

func (c *tagClient) AddTags(ctx context.Context, in *AddTagsReq, opts ...grpc.CallOption) (*AddTagsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddTagsResp)
	err := c.cc.Invoke(ctx, Tag_AddTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagClient) DeleteTags(ctx context.Context, in *DeleteTagsReq, opts ...grpc.CallOption) (*DeleteTagsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteTagsResp)
	err := c.cc.Invoke(ctx, Tag_DeleteTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagClient) MustDeleteTags(ctx context.Context, in *MustDeleteTagsReq, opts ...grpc.CallOption) (*MustDeleteTagsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MustDeleteTagsResp)
	err := c.cc.Invoke(ctx, Tag_MustDeleteTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagClient) UpdateTags(ctx context.Context, in *UpdateTagsReq, opts ...grpc.CallOption) (*UpdateTagsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateTagsResp)
	err := c.cc.Invoke(ctx, Tag_UpdateTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagClient) GetAllTags(ctx context.Context, in *GetAllTagsReq, opts ...grpc.CallOption) (*GetAllTagsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAllTagsResp)
	err := c.cc.Invoke(ctx, Tag_GetAllTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagClient) ProblemAddTags(ctx context.Context, in *ProblemAddTagsReq, opts ...grpc.CallOption) (*ProblemAddTagsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProblemAddTagsResp)
	err := c.cc.Invoke(ctx, Tag_ProblemAddTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagClient) ProblemDeleteTags(ctx context.Context, in *ProblemDeleteTagsReq, opts ...grpc.CallOption) (*ProblemDeleteTagsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProblemDeleteTagsResp)
	err := c.cc.Invoke(ctx, Tag_ProblemDeleteTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagClient) GetProblemTags(ctx context.Context, in *GetProblemTagsReq, opts ...grpc.CallOption) (*GetProblemTagsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProblemTagsResp)
	err := c.cc.Invoke(ctx, Tag_GetProblemTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TagServer is the server API for Tag service.
// All implementations must embed UnimplementedTagServer
// for forward compatibility
//
// 标签
type TagServer interface {
	// 添加标签
	AddTags(context.Context, *AddTagsReq) (*AddTagsResp, error)
	// 删除标签
	DeleteTags(context.Context, *DeleteTagsReq) (*DeleteTagsResp, error)
	// 强行删除标签
	MustDeleteTags(context.Context, *MustDeleteTagsReq) (*MustDeleteTagsResp, error)
	// 更新标签
	UpdateTags(context.Context, *UpdateTagsReq) (*UpdateTagsResp, error)
	// 获取所有标签，可缓存
	GetAllTags(context.Context, *GetAllTagsReq) (*GetAllTagsResp, error)
	// 给题目添加标签，最多5个
	ProblemAddTags(context.Context, *ProblemAddTagsReq) (*ProblemAddTagsResp, error)
	// 给题目删除标签
	ProblemDeleteTags(context.Context, *ProblemDeleteTagsReq) (*ProblemDeleteTagsResp, error)
	// 获取一个题目的所有标签，可缓存
	GetProblemTags(context.Context, *GetProblemTagsReq) (*GetProblemTagsResp, error)
	mustEmbedUnimplementedTagServer()
}

// UnimplementedTagServer must be embedded to have forward compatible implementations.
type UnimplementedTagServer struct {
}

func (UnimplementedTagServer) AddTags(context.Context, *AddTagsReq) (*AddTagsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddTags not implemented")
}
func (UnimplementedTagServer) DeleteTags(context.Context, *DeleteTagsReq) (*DeleteTagsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTags not implemented")
}
func (UnimplementedTagServer) MustDeleteTags(context.Context, *MustDeleteTagsReq) (*MustDeleteTagsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MustDeleteTags not implemented")
}
func (UnimplementedTagServer) UpdateTags(context.Context, *UpdateTagsReq) (*UpdateTagsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTags not implemented")
}
func (UnimplementedTagServer) GetAllTags(context.Context, *GetAllTagsReq) (*GetAllTagsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllTags not implemented")
}
func (UnimplementedTagServer) ProblemAddTags(context.Context, *ProblemAddTagsReq) (*ProblemAddTagsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProblemAddTags not implemented")
}
func (UnimplementedTagServer) ProblemDeleteTags(context.Context, *ProblemDeleteTagsReq) (*ProblemDeleteTagsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProblemDeleteTags not implemented")
}
func (UnimplementedTagServer) GetProblemTags(context.Context, *GetProblemTagsReq) (*GetProblemTagsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProblemTags not implemented")
}
func (UnimplementedTagServer) mustEmbedUnimplementedTagServer() {}

// UnsafeTagServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TagServer will
// result in compilation errors.
type UnsafeTagServer interface {
	mustEmbedUnimplementedTagServer()
}

func RegisterTagServer(s grpc.ServiceRegistrar, srv TagServer) {
	s.RegisterService(&Tag_ServiceDesc, srv)
}

func _Tag_AddTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddTagsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServer).AddTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tag_AddTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServer).AddTags(ctx, req.(*AddTagsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tag_DeleteTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTagsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServer).DeleteTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tag_DeleteTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServer).DeleteTags(ctx, req.(*DeleteTagsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tag_MustDeleteTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MustDeleteTagsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServer).MustDeleteTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tag_MustDeleteTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServer).MustDeleteTags(ctx, req.(*MustDeleteTagsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tag_UpdateTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTagsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServer).UpdateTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tag_UpdateTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServer).UpdateTags(ctx, req.(*UpdateTagsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tag_GetAllTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllTagsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServer).GetAllTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tag_GetAllTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServer).GetAllTags(ctx, req.(*GetAllTagsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tag_ProblemAddTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProblemAddTagsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServer).ProblemAddTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tag_ProblemAddTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServer).ProblemAddTags(ctx, req.(*ProblemAddTagsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tag_ProblemDeleteTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProblemDeleteTagsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServer).ProblemDeleteTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tag_ProblemDeleteTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServer).ProblemDeleteTags(ctx, req.(*ProblemDeleteTagsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tag_GetProblemTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProblemTagsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServer).GetProblemTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tag_GetProblemTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServer).GetProblemTags(ctx, req.(*GetProblemTagsReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Tag_ServiceDesc is the grpc.ServiceDesc for Tag service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Tag_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "problemset.Tag",
	HandlerType: (*TagServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddTags",
			Handler:    _Tag_AddTags_Handler,
		},
		{
			MethodName: "DeleteTags",
			Handler:    _Tag_DeleteTags_Handler,
		},
		{
			MethodName: "MustDeleteTags",
			Handler:    _Tag_MustDeleteTags_Handler,
		},
		{
			MethodName: "UpdateTags",
			Handler:    _Tag_UpdateTags_Handler,
		},
		{
			MethodName: "GetAllTags",
			Handler:    _Tag_GetAllTags_Handler,
		},
		{
			MethodName: "ProblemAddTags",
			Handler:    _Tag_ProblemAddTags_Handler,
		},
		{
			MethodName: "ProblemDeleteTags",
			Handler:    _Tag_ProblemDeleteTags_Handler,
		},
		{
			MethodName: "GetProblemTags",
			Handler:    _Tag_GetProblemTags_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "problemset.proto",
}

const (
	Example_AddExample_FullMethodName         = "/problemset.Example/AddExample"
	Example_DeleteExample_FullMethodName      = "/problemset.Example/DeleteExample"
	Example_UpdateExample_FullMethodName      = "/problemset.Example/UpdateExample"
	Example_GetExample_FullMethodName         = "/problemset.Example/GetExample"
	Example_GetProblemExamples_FullMethodName = "/problemset.Example/GetProblemExamples"
)

// ExampleClient is the client API for Example service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 样例
type ExampleClient interface {
	// 添加样例
	AddExample(ctx context.Context, opts ...grpc.CallOption) (Example_AddExampleClient, error)
	// 删除样例
	DeleteExample(ctx context.Context, in *DeleteExampleReq, opts ...grpc.CallOption) (*DeleteExampleResp, error)
	// 修改样例
	UpdateExample(ctx context.Context, opts ...grpc.CallOption) (Example_UpdateExampleClient, error)
	// 获取样例
	GetExample(ctx context.Context, in *GetExampleReq, opts ...grpc.CallOption) (Example_GetExampleClient, error)
	// 获取题目的所有样例
	GetProblemExamples(ctx context.Context, in *GetProblemExamplesReq, opts ...grpc.CallOption) (Example_GetProblemExamplesClient, error)
}

type exampleClient struct {
	cc grpc.ClientConnInterface
}

func NewExampleClient(cc grpc.ClientConnInterface) ExampleClient {
	return &exampleClient{cc}
}

func (c *exampleClient) AddExample(ctx context.Context, opts ...grpc.CallOption) (Example_AddExampleClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Example_ServiceDesc.Streams[0], Example_AddExample_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &exampleAddExampleClient{ClientStream: stream}
	return x, nil
}

type Example_AddExampleClient interface {
	Send(*AddExampleReq) error
	CloseAndRecv() (*AddExampleResp, error)
	grpc.ClientStream
}

type exampleAddExampleClient struct {
	grpc.ClientStream
}

func (x *exampleAddExampleClient) Send(m *AddExampleReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *exampleAddExampleClient) CloseAndRecv() (*AddExampleResp, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(AddExampleResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *exampleClient) DeleteExample(ctx context.Context, in *DeleteExampleReq, opts ...grpc.CallOption) (*DeleteExampleResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteExampleResp)
	err := c.cc.Invoke(ctx, Example_DeleteExample_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exampleClient) UpdateExample(ctx context.Context, opts ...grpc.CallOption) (Example_UpdateExampleClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Example_ServiceDesc.Streams[1], Example_UpdateExample_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &exampleUpdateExampleClient{ClientStream: stream}
	return x, nil
}

type Example_UpdateExampleClient interface {
	Send(*UpdateExampleReq) error
	CloseAndRecv() (*UpdateExampleResp, error)
	grpc.ClientStream
}

type exampleUpdateExampleClient struct {
	grpc.ClientStream
}

func (x *exampleUpdateExampleClient) Send(m *UpdateExampleReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *exampleUpdateExampleClient) CloseAndRecv() (*UpdateExampleResp, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UpdateExampleResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *exampleClient) GetExample(ctx context.Context, in *GetExampleReq, opts ...grpc.CallOption) (Example_GetExampleClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Example_ServiceDesc.Streams[2], Example_GetExample_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &exampleGetExampleClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Example_GetExampleClient interface {
	Recv() (*GetExampleResp, error)
	grpc.ClientStream
}

type exampleGetExampleClient struct {
	grpc.ClientStream
}

func (x *exampleGetExampleClient) Recv() (*GetExampleResp, error) {
	m := new(GetExampleResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *exampleClient) GetProblemExamples(ctx context.Context, in *GetProblemExamplesReq, opts ...grpc.CallOption) (Example_GetProblemExamplesClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Example_ServiceDesc.Streams[3], Example_GetProblemExamples_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &exampleGetProblemExamplesClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Example_GetProblemExamplesClient interface {
	Recv() (*GetProblemExamplesResp, error)
	grpc.ClientStream
}

type exampleGetProblemExamplesClient struct {
	grpc.ClientStream
}

func (x *exampleGetProblemExamplesClient) Recv() (*GetProblemExamplesResp, error) {
	m := new(GetProblemExamplesResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ExampleServer is the server API for Example service.
// All implementations must embed UnimplementedExampleServer
// for forward compatibility
//
// 样例
type ExampleServer interface {
	// 添加样例
	AddExample(Example_AddExampleServer) error
	// 删除样例
	DeleteExample(context.Context, *DeleteExampleReq) (*DeleteExampleResp, error)
	// 修改样例
	UpdateExample(Example_UpdateExampleServer) error
	// 获取样例
	GetExample(*GetExampleReq, Example_GetExampleServer) error
	// 获取题目的所有样例
	GetProblemExamples(*GetProblemExamplesReq, Example_GetProblemExamplesServer) error
	mustEmbedUnimplementedExampleServer()
}

// UnimplementedExampleServer must be embedded to have forward compatible implementations.
type UnimplementedExampleServer struct {
}

func (UnimplementedExampleServer) AddExample(Example_AddExampleServer) error {
	return status.Errorf(codes.Unimplemented, "method AddExample not implemented")
}
func (UnimplementedExampleServer) DeleteExample(context.Context, *DeleteExampleReq) (*DeleteExampleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteExample not implemented")
}
func (UnimplementedExampleServer) UpdateExample(Example_UpdateExampleServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateExample not implemented")
}
func (UnimplementedExampleServer) GetExample(*GetExampleReq, Example_GetExampleServer) error {
	return status.Errorf(codes.Unimplemented, "method GetExample not implemented")
}
func (UnimplementedExampleServer) GetProblemExamples(*GetProblemExamplesReq, Example_GetProblemExamplesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetProblemExamples not implemented")
}
func (UnimplementedExampleServer) mustEmbedUnimplementedExampleServer() {}

// UnsafeExampleServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ExampleServer will
// result in compilation errors.
type UnsafeExampleServer interface {
	mustEmbedUnimplementedExampleServer()
}

func RegisterExampleServer(s grpc.ServiceRegistrar, srv ExampleServer) {
	s.RegisterService(&Example_ServiceDesc, srv)
}

func _Example_AddExample_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ExampleServer).AddExample(&exampleAddExampleServer{ServerStream: stream})
}

type Example_AddExampleServer interface {
	SendAndClose(*AddExampleResp) error
	Recv() (*AddExampleReq, error)
	grpc.ServerStream
}

type exampleAddExampleServer struct {
	grpc.ServerStream
}

func (x *exampleAddExampleServer) SendAndClose(m *AddExampleResp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *exampleAddExampleServer) Recv() (*AddExampleReq, error) {
	m := new(AddExampleReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Example_DeleteExample_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteExampleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExampleServer).DeleteExample(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Example_DeleteExample_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExampleServer).DeleteExample(ctx, req.(*DeleteExampleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Example_UpdateExample_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ExampleServer).UpdateExample(&exampleUpdateExampleServer{ServerStream: stream})
}

type Example_UpdateExampleServer interface {
	SendAndClose(*UpdateExampleResp) error
	Recv() (*UpdateExampleReq, error)
	grpc.ServerStream
}

type exampleUpdateExampleServer struct {
	grpc.ServerStream
}

func (x *exampleUpdateExampleServer) SendAndClose(m *UpdateExampleResp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *exampleUpdateExampleServer) Recv() (*UpdateExampleReq, error) {
	m := new(UpdateExampleReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Example_GetExample_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetExampleReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ExampleServer).GetExample(m, &exampleGetExampleServer{ServerStream: stream})
}

type Example_GetExampleServer interface {
	Send(*GetExampleResp) error
	grpc.ServerStream
}

type exampleGetExampleServer struct {
	grpc.ServerStream
}

func (x *exampleGetExampleServer) Send(m *GetExampleResp) error {
	return x.ServerStream.SendMsg(m)
}

func _Example_GetProblemExamples_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetProblemExamplesReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ExampleServer).GetProblemExamples(m, &exampleGetProblemExamplesServer{ServerStream: stream})
}

type Example_GetProblemExamplesServer interface {
	Send(*GetProblemExamplesResp) error
	grpc.ServerStream
}

type exampleGetProblemExamplesServer struct {
	grpc.ServerStream
}

func (x *exampleGetProblemExamplesServer) Send(m *GetProblemExamplesResp) error {
	return x.ServerStream.SendMsg(m)
}

// Example_ServiceDesc is the grpc.ServiceDesc for Example service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Example_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "problemset.Example",
	HandlerType: (*ExampleServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DeleteExample",
			Handler:    _Example_DeleteExample_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AddExample",
			Handler:       _Example_AddExample_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "UpdateExample",
			Handler:       _Example_UpdateExample_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "GetExample",
			Handler:       _Example_GetExample_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetProblemExamples",
			Handler:       _Example_GetProblemExamples_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "problemset.proto",
}

const (
	Hint_AddHint_FullMethodName         = "/problemset.Hint/AddHint"
	Hint_DeleteHint_FullMethodName      = "/problemset.Hint/DeleteHint"
	Hint_UpdateHint_FullMethodName      = "/problemset.Hint/UpdateHint"
	Hint_GetHint_FullMethodName         = "/problemset.Hint/GetHint"
	Hint_GetProblemHints_FullMethodName = "/problemset.Hint/GetProblemHints"
)

// HintClient is the client API for Hint service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 提示
type HintClient interface {
	// 添加提示
	AddHint(ctx context.Context, opts ...grpc.CallOption) (Hint_AddHintClient, error)
	// 删除提示
	DeleteHint(ctx context.Context, in *DeleteHintReq, opts ...grpc.CallOption) (*DeleteHintResp, error)
	// 修改提示
	UpdateHint(ctx context.Context, opts ...grpc.CallOption) (Hint_UpdateHintClient, error)
	// 获取提示
	GetHint(ctx context.Context, in *GetHintReq, opts ...grpc.CallOption) (Hint_GetHintClient, error)
	// 获取题目所有提示
	GetProblemHints(ctx context.Context, in *GetProblemHintsReq, opts ...grpc.CallOption) (Hint_GetProblemHintsClient, error)
}

type hintClient struct {
	cc grpc.ClientConnInterface
}

func NewHintClient(cc grpc.ClientConnInterface) HintClient {
	return &hintClient{cc}
}

func (c *hintClient) AddHint(ctx context.Context, opts ...grpc.CallOption) (Hint_AddHintClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Hint_ServiceDesc.Streams[0], Hint_AddHint_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &hintAddHintClient{ClientStream: stream}
	return x, nil
}

type Hint_AddHintClient interface {
	Send(*AddHintReq) error
	CloseAndRecv() (*AddHintResp, error)
	grpc.ClientStream
}

type hintAddHintClient struct {
	grpc.ClientStream
}

func (x *hintAddHintClient) Send(m *AddHintReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *hintAddHintClient) CloseAndRecv() (*AddHintResp, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(AddHintResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *hintClient) DeleteHint(ctx context.Context, in *DeleteHintReq, opts ...grpc.CallOption) (*DeleteHintResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteHintResp)
	err := c.cc.Invoke(ctx, Hint_DeleteHint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hintClient) UpdateHint(ctx context.Context, opts ...grpc.CallOption) (Hint_UpdateHintClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Hint_ServiceDesc.Streams[1], Hint_UpdateHint_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &hintUpdateHintClient{ClientStream: stream}
	return x, nil
}

type Hint_UpdateHintClient interface {
	Send(*UpdateHintReq) error
	CloseAndRecv() (*UpdateHintResp, error)
	grpc.ClientStream
}

type hintUpdateHintClient struct {
	grpc.ClientStream
}

func (x *hintUpdateHintClient) Send(m *UpdateHintReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *hintUpdateHintClient) CloseAndRecv() (*UpdateHintResp, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UpdateHintResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *hintClient) GetHint(ctx context.Context, in *GetHintReq, opts ...grpc.CallOption) (Hint_GetHintClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Hint_ServiceDesc.Streams[2], Hint_GetHint_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &hintGetHintClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Hint_GetHintClient interface {
	Recv() (*GetHintResp, error)
	grpc.ClientStream
}

type hintGetHintClient struct {
	grpc.ClientStream
}

func (x *hintGetHintClient) Recv() (*GetHintResp, error) {
	m := new(GetHintResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *hintClient) GetProblemHints(ctx context.Context, in *GetProblemHintsReq, opts ...grpc.CallOption) (Hint_GetProblemHintsClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Hint_ServiceDesc.Streams[3], Hint_GetProblemHints_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &hintGetProblemHintsClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Hint_GetProblemHintsClient interface {
	Recv() (*GetProblemHintsResp, error)
	grpc.ClientStream
}

type hintGetProblemHintsClient struct {
	grpc.ClientStream
}

func (x *hintGetProblemHintsClient) Recv() (*GetProblemHintsResp, error) {
	m := new(GetProblemHintsResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// HintServer is the server API for Hint service.
// All implementations must embed UnimplementedHintServer
// for forward compatibility
//
// 提示
type HintServer interface {
	// 添加提示
	AddHint(Hint_AddHintServer) error
	// 删除提示
	DeleteHint(context.Context, *DeleteHintReq) (*DeleteHintResp, error)
	// 修改提示
	UpdateHint(Hint_UpdateHintServer) error
	// 获取提示
	GetHint(*GetHintReq, Hint_GetHintServer) error
	// 获取题目所有提示
	GetProblemHints(*GetProblemHintsReq, Hint_GetProblemHintsServer) error
	mustEmbedUnimplementedHintServer()
}

// UnimplementedHintServer must be embedded to have forward compatible implementations.
type UnimplementedHintServer struct {
}

func (UnimplementedHintServer) AddHint(Hint_AddHintServer) error {
	return status.Errorf(codes.Unimplemented, "method AddHint not implemented")
}
func (UnimplementedHintServer) DeleteHint(context.Context, *DeleteHintReq) (*DeleteHintResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteHint not implemented")
}
func (UnimplementedHintServer) UpdateHint(Hint_UpdateHintServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateHint not implemented")
}
func (UnimplementedHintServer) GetHint(*GetHintReq, Hint_GetHintServer) error {
	return status.Errorf(codes.Unimplemented, "method GetHint not implemented")
}
func (UnimplementedHintServer) GetProblemHints(*GetProblemHintsReq, Hint_GetProblemHintsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetProblemHints not implemented")
}
func (UnimplementedHintServer) mustEmbedUnimplementedHintServer() {}

// UnsafeHintServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HintServer will
// result in compilation errors.
type UnsafeHintServer interface {
	mustEmbedUnimplementedHintServer()
}

func RegisterHintServer(s grpc.ServiceRegistrar, srv HintServer) {
	s.RegisterService(&Hint_ServiceDesc, srv)
}

func _Hint_AddHint_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(HintServer).AddHint(&hintAddHintServer{ServerStream: stream})
}

type Hint_AddHintServer interface {
	SendAndClose(*AddHintResp) error
	Recv() (*AddHintReq, error)
	grpc.ServerStream
}

type hintAddHintServer struct {
	grpc.ServerStream
}

func (x *hintAddHintServer) SendAndClose(m *AddHintResp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *hintAddHintServer) Recv() (*AddHintReq, error) {
	m := new(AddHintReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Hint_DeleteHint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteHintReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HintServer).DeleteHint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hint_DeleteHint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HintServer).DeleteHint(ctx, req.(*DeleteHintReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hint_UpdateHint_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(HintServer).UpdateHint(&hintUpdateHintServer{ServerStream: stream})
}

type Hint_UpdateHintServer interface {
	SendAndClose(*UpdateHintResp) error
	Recv() (*UpdateHintReq, error)
	grpc.ServerStream
}

type hintUpdateHintServer struct {
	grpc.ServerStream
}

func (x *hintUpdateHintServer) SendAndClose(m *UpdateHintResp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *hintUpdateHintServer) Recv() (*UpdateHintReq, error) {
	m := new(UpdateHintReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Hint_GetHint_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetHintReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(HintServer).GetHint(m, &hintGetHintServer{ServerStream: stream})
}

type Hint_GetHintServer interface {
	Send(*GetHintResp) error
	grpc.ServerStream
}

type hintGetHintServer struct {
	grpc.ServerStream
}

func (x *hintGetHintServer) Send(m *GetHintResp) error {
	return x.ServerStream.SendMsg(m)
}

func _Hint_GetProblemHints_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetProblemHintsReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(HintServer).GetProblemHints(m, &hintGetProblemHintsServer{ServerStream: stream})
}

type Hint_GetProblemHintsServer interface {
	Send(*GetProblemHintsResp) error
	grpc.ServerStream
}

type hintGetProblemHintsServer struct {
	grpc.ServerStream
}

func (x *hintGetProblemHintsServer) Send(m *GetProblemHintsResp) error {
	return x.ServerStream.SendMsg(m)
}

// Hint_ServiceDesc is the grpc.ServiceDesc for Hint service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Hint_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "problemset.Hint",
	HandlerType: (*HintServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DeleteHint",
			Handler:    _Hint_DeleteHint_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AddHint",
			Handler:       _Hint_AddHint_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "UpdateHint",
			Handler:       _Hint_UpdateHint_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "GetHint",
			Handler:       _Hint_GetHint_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetProblemHints",
			Handler:       _Hint_GetProblemHints_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "problemset.proto",
}

const (
	JudgeData_AddJudgeData_FullMethodName    = "/problemset.JudgeData/AddJudgeData"
	JudgeData_DeleteJudgeData_FullMethodName = "/problemset.JudgeData/DeleteJudgeData"
	JudgeData_UpdateJudgeData_FullMethodName = "/problemset.JudgeData/UpdateJudgeData"
	JudgeData_GetJudgeData_FullMethodName    = "/problemset.JudgeData/GetJudgeData"
)

// JudgeDataClient is the client API for JudgeData service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 评测数据
type JudgeDataClient interface {
	// 添加测评数据
	AddJudgeData(ctx context.Context, opts ...grpc.CallOption) (JudgeData_AddJudgeDataClient, error)
	// 删除测评数据
	DeleteJudgeData(ctx context.Context, in *DeleteJudgeDataReq, opts ...grpc.CallOption) (*DeleteJudgeDataResp, error)
	// 修改测评数据
	UpdateJudgeData(ctx context.Context, opts ...grpc.CallOption) (JudgeData_UpdateJudgeDataClient, error)
	// 获取题目的测评数据，返回minio对象名称，可缓存
	GetJudgeData(ctx context.Context, in *GetJudgeDataReq, opts ...grpc.CallOption) (JudgeData_GetJudgeDataClient, error)
}

type judgeDataClient struct {
	cc grpc.ClientConnInterface
}

func NewJudgeDataClient(cc grpc.ClientConnInterface) JudgeDataClient {
	return &judgeDataClient{cc}
}

func (c *judgeDataClient) AddJudgeData(ctx context.Context, opts ...grpc.CallOption) (JudgeData_AddJudgeDataClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &JudgeData_ServiceDesc.Streams[0], JudgeData_AddJudgeData_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &judgeDataAddJudgeDataClient{ClientStream: stream}
	return x, nil
}

type JudgeData_AddJudgeDataClient interface {
	Send(*AddJudgeDataReq) error
	CloseAndRecv() (*AddJudgeDataResp, error)
	grpc.ClientStream
}

type judgeDataAddJudgeDataClient struct {
	grpc.ClientStream
}

func (x *judgeDataAddJudgeDataClient) Send(m *AddJudgeDataReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *judgeDataAddJudgeDataClient) CloseAndRecv() (*AddJudgeDataResp, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(AddJudgeDataResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *judgeDataClient) DeleteJudgeData(ctx context.Context, in *DeleteJudgeDataReq, opts ...grpc.CallOption) (*DeleteJudgeDataResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteJudgeDataResp)
	err := c.cc.Invoke(ctx, JudgeData_DeleteJudgeData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeDataClient) UpdateJudgeData(ctx context.Context, opts ...grpc.CallOption) (JudgeData_UpdateJudgeDataClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &JudgeData_ServiceDesc.Streams[1], JudgeData_UpdateJudgeData_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &judgeDataUpdateJudgeDataClient{ClientStream: stream}
	return x, nil
}

type JudgeData_UpdateJudgeDataClient interface {
	Send(*UpdateJudgeDataReq) error
	CloseAndRecv() (*UpdateJudgeDataResp, error)
	grpc.ClientStream
}

type judgeDataUpdateJudgeDataClient struct {
	grpc.ClientStream
}

func (x *judgeDataUpdateJudgeDataClient) Send(m *UpdateJudgeDataReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *judgeDataUpdateJudgeDataClient) CloseAndRecv() (*UpdateJudgeDataResp, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UpdateJudgeDataResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *judgeDataClient) GetJudgeData(ctx context.Context, in *GetJudgeDataReq, opts ...grpc.CallOption) (JudgeData_GetJudgeDataClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &JudgeData_ServiceDesc.Streams[2], JudgeData_GetJudgeData_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &judgeDataGetJudgeDataClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type JudgeData_GetJudgeDataClient interface {
	Recv() (*GetJudgeDataResp, error)
	grpc.ClientStream
}

type judgeDataGetJudgeDataClient struct {
	grpc.ClientStream
}

func (x *judgeDataGetJudgeDataClient) Recv() (*GetJudgeDataResp, error) {
	m := new(GetJudgeDataResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// JudgeDataServer is the server API for JudgeData service.
// All implementations must embed UnimplementedJudgeDataServer
// for forward compatibility
//
// 评测数据
type JudgeDataServer interface {
	// 添加测评数据
	AddJudgeData(JudgeData_AddJudgeDataServer) error
	// 删除测评数据
	DeleteJudgeData(context.Context, *DeleteJudgeDataReq) (*DeleteJudgeDataResp, error)
	// 修改测评数据
	UpdateJudgeData(JudgeData_UpdateJudgeDataServer) error
	// 获取题目的测评数据，返回minio对象名称，可缓存
	GetJudgeData(*GetJudgeDataReq, JudgeData_GetJudgeDataServer) error
	mustEmbedUnimplementedJudgeDataServer()
}

// UnimplementedJudgeDataServer must be embedded to have forward compatible implementations.
type UnimplementedJudgeDataServer struct {
}

func (UnimplementedJudgeDataServer) AddJudgeData(JudgeData_AddJudgeDataServer) error {
	return status.Errorf(codes.Unimplemented, "method AddJudgeData not implemented")
}
func (UnimplementedJudgeDataServer) DeleteJudgeData(context.Context, *DeleteJudgeDataReq) (*DeleteJudgeDataResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteJudgeData not implemented")
}
func (UnimplementedJudgeDataServer) UpdateJudgeData(JudgeData_UpdateJudgeDataServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateJudgeData not implemented")
}
func (UnimplementedJudgeDataServer) GetJudgeData(*GetJudgeDataReq, JudgeData_GetJudgeDataServer) error {
	return status.Errorf(codes.Unimplemented, "method GetJudgeData not implemented")
}
func (UnimplementedJudgeDataServer) mustEmbedUnimplementedJudgeDataServer() {}

// UnsafeJudgeDataServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to JudgeDataServer will
// result in compilation errors.
type UnsafeJudgeDataServer interface {
	mustEmbedUnimplementedJudgeDataServer()
}

func RegisterJudgeDataServer(s grpc.ServiceRegistrar, srv JudgeDataServer) {
	s.RegisterService(&JudgeData_ServiceDesc, srv)
}

func _JudgeData_AddJudgeData_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(JudgeDataServer).AddJudgeData(&judgeDataAddJudgeDataServer{ServerStream: stream})
}

type JudgeData_AddJudgeDataServer interface {
	SendAndClose(*AddJudgeDataResp) error
	Recv() (*AddJudgeDataReq, error)
	grpc.ServerStream
}

type judgeDataAddJudgeDataServer struct {
	grpc.ServerStream
}

func (x *judgeDataAddJudgeDataServer) SendAndClose(m *AddJudgeDataResp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *judgeDataAddJudgeDataServer) Recv() (*AddJudgeDataReq, error) {
	m := new(AddJudgeDataReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _JudgeData_DeleteJudgeData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteJudgeDataReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeDataServer).DeleteJudgeData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JudgeData_DeleteJudgeData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeDataServer).DeleteJudgeData(ctx, req.(*DeleteJudgeDataReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _JudgeData_UpdateJudgeData_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(JudgeDataServer).UpdateJudgeData(&judgeDataUpdateJudgeDataServer{ServerStream: stream})
}

type JudgeData_UpdateJudgeDataServer interface {
	SendAndClose(*UpdateJudgeDataResp) error
	Recv() (*UpdateJudgeDataReq, error)
	grpc.ServerStream
}

type judgeDataUpdateJudgeDataServer struct {
	grpc.ServerStream
}

func (x *judgeDataUpdateJudgeDataServer) SendAndClose(m *UpdateJudgeDataResp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *judgeDataUpdateJudgeDataServer) Recv() (*UpdateJudgeDataReq, error) {
	m := new(UpdateJudgeDataReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _JudgeData_GetJudgeData_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetJudgeDataReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(JudgeDataServer).GetJudgeData(m, &judgeDataGetJudgeDataServer{ServerStream: stream})
}

type JudgeData_GetJudgeDataServer interface {
	Send(*GetJudgeDataResp) error
	grpc.ServerStream
}

type judgeDataGetJudgeDataServer struct {
	grpc.ServerStream
}

func (x *judgeDataGetJudgeDataServer) Send(m *GetJudgeDataResp) error {
	return x.ServerStream.SendMsg(m)
}

// JudgeData_ServiceDesc is the grpc.ServiceDesc for JudgeData service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var JudgeData_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "problemset.JudgeData",
	HandlerType: (*JudgeDataServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DeleteJudgeData",
			Handler:    _JudgeData_DeleteJudgeData_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AddJudgeData",
			Handler:       _JudgeData_AddJudgeData_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "UpdateJudgeData",
			Handler:       _JudgeData_UpdateJudgeData_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "GetJudgeData",
			Handler:       _JudgeData_GetJudgeData_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "problemset.proto",
}

const (
	Language_AddLanguage_FullMethodName            = "/problemset.Language/AddLanguage"
	Language_DeleteLanguage_FullMethodName         = "/problemset.Language/DeleteLanguage"
	Language_UpdateLanguage_FullMethodName         = "/problemset.Language/UpdateLanguage"
	Language_GetLanguages_FullMethodName           = "/problemset.Language/GetLanguages"
	Language_GetLanguageById_FullMethodName        = "/problemset.Language/GetLanguageById"
	Language_ProblemAddLanguages_FullMethodName    = "/problemset.Language/ProblemAddLanguages"
	Language_ProblemDeleteLanguages_FullMethodName = "/problemset.Language/ProblemDeleteLanguages"
	Language_GetProblemLanguages_FullMethodName    = "/problemset.Language/GetProblemLanguages"
)

// LanguageClient is the client API for Language service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 编程语言
type LanguageClient interface {
	// 添加语言
	AddLanguage(ctx context.Context, in *AddLanguageReq, opts ...grpc.CallOption) (*AddLanguageResp, error)
	// 删除语言
	DeleteLanguage(ctx context.Context, in *DeleteLanguageReq, opts ...grpc.CallOption) (*DeleteLanguageResp, error)
	// 更新语言
	UpdateLanguage(ctx context.Context, in *UpdateLanguageReq, opts ...grpc.CallOption) (*UpdateLanguageResp, error)
	// 获取所有语言
	GetLanguages(ctx context.Context, in *GetLanguagesReq, opts ...grpc.CallOption) (*GetLanguagesResp, error)
	// 根据id获取语言
	GetLanguageById(ctx context.Context, in *GetLanguageByIdReq, opts ...grpc.CallOption) (*GetLanguageByIdResp, error)
	// 给题目增加语言
	ProblemAddLanguages(ctx context.Context, in *ProblemAddLanguagesReq, opts ...grpc.CallOption) (*ProblemAddLanguagesResp, error)
	// 题目删除语言
	ProblemDeleteLanguages(ctx context.Context, in *ProblemDeleteLanguagesReq, opts ...grpc.CallOption) (*ProblemDeleteLanguagesResp, error)
	// 获取题目的所有语言
	GetProblemLanguages(ctx context.Context, in *GetProblemLanguagesReq, opts ...grpc.CallOption) (*GetProblemLanguagesResp, error)
}

type languageClient struct {
	cc grpc.ClientConnInterface
}

func NewLanguageClient(cc grpc.ClientConnInterface) LanguageClient {
	return &languageClient{cc}
}

func (c *languageClient) AddLanguage(ctx context.Context, in *AddLanguageReq, opts ...grpc.CallOption) (*AddLanguageResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddLanguageResp)
	err := c.cc.Invoke(ctx, Language_AddLanguage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageClient) DeleteLanguage(ctx context.Context, in *DeleteLanguageReq, opts ...grpc.CallOption) (*DeleteLanguageResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteLanguageResp)
	err := c.cc.Invoke(ctx, Language_DeleteLanguage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageClient) UpdateLanguage(ctx context.Context, in *UpdateLanguageReq, opts ...grpc.CallOption) (*UpdateLanguageResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateLanguageResp)
	err := c.cc.Invoke(ctx, Language_UpdateLanguage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageClient) GetLanguages(ctx context.Context, in *GetLanguagesReq, opts ...grpc.CallOption) (*GetLanguagesResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLanguagesResp)
	err := c.cc.Invoke(ctx, Language_GetLanguages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageClient) GetLanguageById(ctx context.Context, in *GetLanguageByIdReq, opts ...grpc.CallOption) (*GetLanguageByIdResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLanguageByIdResp)
	err := c.cc.Invoke(ctx, Language_GetLanguageById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageClient) ProblemAddLanguages(ctx context.Context, in *ProblemAddLanguagesReq, opts ...grpc.CallOption) (*ProblemAddLanguagesResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProblemAddLanguagesResp)
	err := c.cc.Invoke(ctx, Language_ProblemAddLanguages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageClient) ProblemDeleteLanguages(ctx context.Context, in *ProblemDeleteLanguagesReq, opts ...grpc.CallOption) (*ProblemDeleteLanguagesResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProblemDeleteLanguagesResp)
	err := c.cc.Invoke(ctx, Language_ProblemDeleteLanguages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageClient) GetProblemLanguages(ctx context.Context, in *GetProblemLanguagesReq, opts ...grpc.CallOption) (*GetProblemLanguagesResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProblemLanguagesResp)
	err := c.cc.Invoke(ctx, Language_GetProblemLanguages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LanguageServer is the server API for Language service.
// All implementations must embed UnimplementedLanguageServer
// for forward compatibility
//
// 编程语言
type LanguageServer interface {
	// 添加语言
	AddLanguage(context.Context, *AddLanguageReq) (*AddLanguageResp, error)
	// 删除语言
	DeleteLanguage(context.Context, *DeleteLanguageReq) (*DeleteLanguageResp, error)
	// 更新语言
	UpdateLanguage(context.Context, *UpdateLanguageReq) (*UpdateLanguageResp, error)
	// 获取所有语言
	GetLanguages(context.Context, *GetLanguagesReq) (*GetLanguagesResp, error)
	// 根据id获取语言
	GetLanguageById(context.Context, *GetLanguageByIdReq) (*GetLanguageByIdResp, error)
	// 给题目增加语言
	ProblemAddLanguages(context.Context, *ProblemAddLanguagesReq) (*ProblemAddLanguagesResp, error)
	// 题目删除语言
	ProblemDeleteLanguages(context.Context, *ProblemDeleteLanguagesReq) (*ProblemDeleteLanguagesResp, error)
	// 获取题目的所有语言
	GetProblemLanguages(context.Context, *GetProblemLanguagesReq) (*GetProblemLanguagesResp, error)
	mustEmbedUnimplementedLanguageServer()
}

// UnimplementedLanguageServer must be embedded to have forward compatible implementations.
type UnimplementedLanguageServer struct {
}

func (UnimplementedLanguageServer) AddLanguage(context.Context, *AddLanguageReq) (*AddLanguageResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddLanguage not implemented")
}
func (UnimplementedLanguageServer) DeleteLanguage(context.Context, *DeleteLanguageReq) (*DeleteLanguageResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteLanguage not implemented")
}
func (UnimplementedLanguageServer) UpdateLanguage(context.Context, *UpdateLanguageReq) (*UpdateLanguageResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateLanguage not implemented")
}
func (UnimplementedLanguageServer) GetLanguages(context.Context, *GetLanguagesReq) (*GetLanguagesResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLanguages not implemented")
}
func (UnimplementedLanguageServer) GetLanguageById(context.Context, *GetLanguageByIdReq) (*GetLanguageByIdResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLanguageById not implemented")
}
func (UnimplementedLanguageServer) ProblemAddLanguages(context.Context, *ProblemAddLanguagesReq) (*ProblemAddLanguagesResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProblemAddLanguages not implemented")
}
func (UnimplementedLanguageServer) ProblemDeleteLanguages(context.Context, *ProblemDeleteLanguagesReq) (*ProblemDeleteLanguagesResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProblemDeleteLanguages not implemented")
}
func (UnimplementedLanguageServer) GetProblemLanguages(context.Context, *GetProblemLanguagesReq) (*GetProblemLanguagesResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProblemLanguages not implemented")
}
func (UnimplementedLanguageServer) mustEmbedUnimplementedLanguageServer() {}

// UnsafeLanguageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LanguageServer will
// result in compilation errors.
type UnsafeLanguageServer interface {
	mustEmbedUnimplementedLanguageServer()
}

func RegisterLanguageServer(s grpc.ServiceRegistrar, srv LanguageServer) {
	s.RegisterService(&Language_ServiceDesc, srv)
}

func _Language_AddLanguage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddLanguageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServer).AddLanguage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Language_AddLanguage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServer).AddLanguage(ctx, req.(*AddLanguageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Language_DeleteLanguage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteLanguageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServer).DeleteLanguage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Language_DeleteLanguage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServer).DeleteLanguage(ctx, req.(*DeleteLanguageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Language_UpdateLanguage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateLanguageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServer).UpdateLanguage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Language_UpdateLanguage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServer).UpdateLanguage(ctx, req.(*UpdateLanguageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Language_GetLanguages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLanguagesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServer).GetLanguages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Language_GetLanguages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServer).GetLanguages(ctx, req.(*GetLanguagesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Language_GetLanguageById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLanguageByIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServer).GetLanguageById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Language_GetLanguageById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServer).GetLanguageById(ctx, req.(*GetLanguageByIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Language_ProblemAddLanguages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProblemAddLanguagesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServer).ProblemAddLanguages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Language_ProblemAddLanguages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServer).ProblemAddLanguages(ctx, req.(*ProblemAddLanguagesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Language_ProblemDeleteLanguages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProblemDeleteLanguagesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServer).ProblemDeleteLanguages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Language_ProblemDeleteLanguages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServer).ProblemDeleteLanguages(ctx, req.(*ProblemDeleteLanguagesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Language_GetProblemLanguages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProblemLanguagesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServer).GetProblemLanguages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Language_GetProblemLanguages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServer).GetProblemLanguages(ctx, req.(*GetProblemLanguagesReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Language_ServiceDesc is the grpc.ServiceDesc for Language service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Language_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "problemset.Language",
	HandlerType: (*LanguageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddLanguage",
			Handler:    _Language_AddLanguage_Handler,
		},
		{
			MethodName: "DeleteLanguage",
			Handler:    _Language_DeleteLanguage_Handler,
		},
		{
			MethodName: "UpdateLanguage",
			Handler:    _Language_UpdateLanguage_Handler,
		},
		{
			MethodName: "GetLanguages",
			Handler:    _Language_GetLanguages_Handler,
		},
		{
			MethodName: "GetLanguageById",
			Handler:    _Language_GetLanguageById_Handler,
		},
		{
			MethodName: "ProblemAddLanguages",
			Handler:    _Language_ProblemAddLanguages_Handler,
		},
		{
			MethodName: "ProblemDeleteLanguages",
			Handler:    _Language_ProblemDeleteLanguages_Handler,
		},
		{
			MethodName: "GetProblemLanguages",
			Handler:    _Language_GetProblemLanguages_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "problemset.proto",
}

const (
	Submit_SubmitCode_FullMethodName            = "/problemset.Submit/SubmitCode"
	Submit_GetProblemSubmitCount_FullMethodName = "/problemset.Submit/GetProblemSubmitCount"
	Submit_GetUserSubmit_FullMethodName         = "/problemset.Submit/GetUserSubmit"
	Submit_GetUserProblemSubmit_FullMethodName  = "/problemset.Submit/GetUserProblemSubmit"
	Submit_GetSubmitById_FullMethodName         = "/problemset.Submit/GetSubmitById"
)

// SubmitClient is the client API for Submit service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 提交
type SubmitClient interface {
	// 用户提交代码
	SubmitCode(ctx context.Context, opts ...grpc.CallOption) (Submit_SubmitCodeClient, error)
	// 获取题目的提交数
	GetProblemSubmitCount(ctx context.Context, in *GetProblemSubmitCountReq, opts ...grpc.CallOption) (*GetProblemSubmitCountResp, error)
	// 分页获取用户提交
	GetUserSubmit(ctx context.Context, in *GetUserSubmitReq, opts ...grpc.CallOption) (Submit_GetUserSubmitClient, error)
	// 获取用户某一道题的全部提交
	GetUserProblemSubmit(ctx context.Context, in *GetUserProblemSubmitReq, opts ...grpc.CallOption) (Submit_GetUserProblemSubmitClient, error)
	// 获取通过id提交记录
	GetSubmitById(ctx context.Context, in *GetSubmitByIdReq, opts ...grpc.CallOption) (Submit_GetSubmitByIdClient, error)
}

type submitClient struct {
	cc grpc.ClientConnInterface
}

func NewSubmitClient(cc grpc.ClientConnInterface) SubmitClient {
	return &submitClient{cc}
}

func (c *submitClient) SubmitCode(ctx context.Context, opts ...grpc.CallOption) (Submit_SubmitCodeClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Submit_ServiceDesc.Streams[0], Submit_SubmitCode_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &submitSubmitCodeClient{ClientStream: stream}
	return x, nil
}

type Submit_SubmitCodeClient interface {
	Send(*SubmitCodeReq) error
	CloseAndRecv() (*SubmitCodeResp, error)
	grpc.ClientStream
}

type submitSubmitCodeClient struct {
	grpc.ClientStream
}

func (x *submitSubmitCodeClient) Send(m *SubmitCodeReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *submitSubmitCodeClient) CloseAndRecv() (*SubmitCodeResp, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(SubmitCodeResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *submitClient) GetProblemSubmitCount(ctx context.Context, in *GetProblemSubmitCountReq, opts ...grpc.CallOption) (*GetProblemSubmitCountResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProblemSubmitCountResp)
	err := c.cc.Invoke(ctx, Submit_GetProblemSubmitCount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *submitClient) GetUserSubmit(ctx context.Context, in *GetUserSubmitReq, opts ...grpc.CallOption) (Submit_GetUserSubmitClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Submit_ServiceDesc.Streams[1], Submit_GetUserSubmit_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &submitGetUserSubmitClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Submit_GetUserSubmitClient interface {
	Recv() (*GetUserSubmitResp, error)
	grpc.ClientStream
}

type submitGetUserSubmitClient struct {
	grpc.ClientStream
}

func (x *submitGetUserSubmitClient) Recv() (*GetUserSubmitResp, error) {
	m := new(GetUserSubmitResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *submitClient) GetUserProblemSubmit(ctx context.Context, in *GetUserProblemSubmitReq, opts ...grpc.CallOption) (Submit_GetUserProblemSubmitClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Submit_ServiceDesc.Streams[2], Submit_GetUserProblemSubmit_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &submitGetUserProblemSubmitClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Submit_GetUserProblemSubmitClient interface {
	Recv() (*GetUserProblemSubmitResp, error)
	grpc.ClientStream
}

type submitGetUserProblemSubmitClient struct {
	grpc.ClientStream
}

func (x *submitGetUserProblemSubmitClient) Recv() (*GetUserProblemSubmitResp, error) {
	m := new(GetUserProblemSubmitResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *submitClient) GetSubmitById(ctx context.Context, in *GetSubmitByIdReq, opts ...grpc.CallOption) (Submit_GetSubmitByIdClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Submit_ServiceDesc.Streams[3], Submit_GetSubmitById_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &submitGetSubmitByIdClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Submit_GetSubmitByIdClient interface {
	Recv() (*GetSubmitByIdResp, error)
	grpc.ClientStream
}

type submitGetSubmitByIdClient struct {
	grpc.ClientStream
}

func (x *submitGetSubmitByIdClient) Recv() (*GetSubmitByIdResp, error) {
	m := new(GetSubmitByIdResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SubmitServer is the server API for Submit service.
// All implementations must embed UnimplementedSubmitServer
// for forward compatibility
//
// 提交
type SubmitServer interface {
	// 用户提交代码
	SubmitCode(Submit_SubmitCodeServer) error
	// 获取题目的提交数
	GetProblemSubmitCount(context.Context, *GetProblemSubmitCountReq) (*GetProblemSubmitCountResp, error)
	// 分页获取用户提交
	GetUserSubmit(*GetUserSubmitReq, Submit_GetUserSubmitServer) error
	// 获取用户某一道题的全部提交
	GetUserProblemSubmit(*GetUserProblemSubmitReq, Submit_GetUserProblemSubmitServer) error
	// 获取通过id提交记录
	GetSubmitById(*GetSubmitByIdReq, Submit_GetSubmitByIdServer) error
	mustEmbedUnimplementedSubmitServer()
}

// UnimplementedSubmitServer must be embedded to have forward compatible implementations.
type UnimplementedSubmitServer struct {
}

func (UnimplementedSubmitServer) SubmitCode(Submit_SubmitCodeServer) error {
	return status.Errorf(codes.Unimplemented, "method SubmitCode not implemented")
}
func (UnimplementedSubmitServer) GetProblemSubmitCount(context.Context, *GetProblemSubmitCountReq) (*GetProblemSubmitCountResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProblemSubmitCount not implemented")
}
func (UnimplementedSubmitServer) GetUserSubmit(*GetUserSubmitReq, Submit_GetUserSubmitServer) error {
	return status.Errorf(codes.Unimplemented, "method GetUserSubmit not implemented")
}
func (UnimplementedSubmitServer) GetUserProblemSubmit(*GetUserProblemSubmitReq, Submit_GetUserProblemSubmitServer) error {
	return status.Errorf(codes.Unimplemented, "method GetUserProblemSubmit not implemented")
}
func (UnimplementedSubmitServer) GetSubmitById(*GetSubmitByIdReq, Submit_GetSubmitByIdServer) error {
	return status.Errorf(codes.Unimplemented, "method GetSubmitById not implemented")
}
func (UnimplementedSubmitServer) mustEmbedUnimplementedSubmitServer() {}

// UnsafeSubmitServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SubmitServer will
// result in compilation errors.
type UnsafeSubmitServer interface {
	mustEmbedUnimplementedSubmitServer()
}

func RegisterSubmitServer(s grpc.ServiceRegistrar, srv SubmitServer) {
	s.RegisterService(&Submit_ServiceDesc, srv)
}

func _Submit_SubmitCode_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SubmitServer).SubmitCode(&submitSubmitCodeServer{ServerStream: stream})
}

type Submit_SubmitCodeServer interface {
	SendAndClose(*SubmitCodeResp) error
	Recv() (*SubmitCodeReq, error)
	grpc.ServerStream
}

type submitSubmitCodeServer struct {
	grpc.ServerStream
}

func (x *submitSubmitCodeServer) SendAndClose(m *SubmitCodeResp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *submitSubmitCodeServer) Recv() (*SubmitCodeReq, error) {
	m := new(SubmitCodeReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Submit_GetProblemSubmitCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProblemSubmitCountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubmitServer).GetProblemSubmitCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Submit_GetProblemSubmitCount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubmitServer).GetProblemSubmitCount(ctx, req.(*GetProblemSubmitCountReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Submit_GetUserSubmit_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetUserSubmitReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SubmitServer).GetUserSubmit(m, &submitGetUserSubmitServer{ServerStream: stream})
}

type Submit_GetUserSubmitServer interface {
	Send(*GetUserSubmitResp) error
	grpc.ServerStream
}

type submitGetUserSubmitServer struct {
	grpc.ServerStream
}

func (x *submitGetUserSubmitServer) Send(m *GetUserSubmitResp) error {
	return x.ServerStream.SendMsg(m)
}

func _Submit_GetUserProblemSubmit_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetUserProblemSubmitReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SubmitServer).GetUserProblemSubmit(m, &submitGetUserProblemSubmitServer{ServerStream: stream})
}

type Submit_GetUserProblemSubmitServer interface {
	Send(*GetUserProblemSubmitResp) error
	grpc.ServerStream
}

type submitGetUserProblemSubmitServer struct {
	grpc.ServerStream
}

func (x *submitGetUserProblemSubmitServer) Send(m *GetUserProblemSubmitResp) error {
	return x.ServerStream.SendMsg(m)
}

func _Submit_GetSubmitById_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetSubmitByIdReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SubmitServer).GetSubmitById(m, &submitGetSubmitByIdServer{ServerStream: stream})
}

type Submit_GetSubmitByIdServer interface {
	Send(*GetSubmitByIdResp) error
	grpc.ServerStream
}

type submitGetSubmitByIdServer struct {
	grpc.ServerStream
}

func (x *submitGetSubmitByIdServer) Send(m *GetSubmitByIdResp) error {
	return x.ServerStream.SendMsg(m)
}

// Submit_ServiceDesc is the grpc.ServiceDesc for Submit service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Submit_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "problemset.Submit",
	HandlerType: (*SubmitServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetProblemSubmitCount",
			Handler:    _Submit_GetProblemSubmitCount_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubmitCode",
			Handler:       _Submit_SubmitCode_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "GetUserSubmit",
			Handler:       _Submit_GetUserSubmit_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetUserProblemSubmit",
			Handler:       _Submit_GetUserProblemSubmit_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetSubmitById",
			Handler:       _Submit_GetSubmitById_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "problemset.proto",
}
