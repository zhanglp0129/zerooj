// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v3.21.12
// source: user.proto

package user

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
	RegisterLogin_UserRegister_FullMethodName = "/user.RegisterLogin/UserRegister"
	RegisterLogin_UserLogin_FullMethodName    = "/user.RegisterLogin/UserLogin"
)

// RegisterLoginClient is the client API for RegisterLogin service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 注册登录
type RegisterLoginClient interface {
	// 用户注册
	UserRegister(ctx context.Context, in *UserRegisterReq, opts ...grpc.CallOption) (*UserRegisterResp, error)
	// 用户登录
	UserLogin(ctx context.Context, in *UserLoginReq, opts ...grpc.CallOption) (*UserLoginResp, error)
}

type registerLoginClient struct {
	cc grpc.ClientConnInterface
}

func NewRegisterLoginClient(cc grpc.ClientConnInterface) RegisterLoginClient {
	return &registerLoginClient{cc}
}

func (c *registerLoginClient) UserRegister(ctx context.Context, in *UserRegisterReq, opts ...grpc.CallOption) (*UserRegisterResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserRegisterResp)
	err := c.cc.Invoke(ctx, RegisterLogin_UserRegister_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registerLoginClient) UserLogin(ctx context.Context, in *UserLoginReq, opts ...grpc.CallOption) (*UserLoginResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserLoginResp)
	err := c.cc.Invoke(ctx, RegisterLogin_UserLogin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegisterLoginServer is the server API for RegisterLogin service.
// All implementations must embed UnimplementedRegisterLoginServer
// for forward compatibility
//
// 注册登录
type RegisterLoginServer interface {
	// 用户注册
	UserRegister(context.Context, *UserRegisterReq) (*UserRegisterResp, error)
	// 用户登录
	UserLogin(context.Context, *UserLoginReq) (*UserLoginResp, error)
	mustEmbedUnimplementedRegisterLoginServer()
}

// UnimplementedRegisterLoginServer must be embedded to have forward compatible implementations.
type UnimplementedRegisterLoginServer struct {
}

func (UnimplementedRegisterLoginServer) UserRegister(context.Context, *UserRegisterReq) (*UserRegisterResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserRegister not implemented")
}
func (UnimplementedRegisterLoginServer) UserLogin(context.Context, *UserLoginReq) (*UserLoginResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserLogin not implemented")
}
func (UnimplementedRegisterLoginServer) mustEmbedUnimplementedRegisterLoginServer() {}

// UnsafeRegisterLoginServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegisterLoginServer will
// result in compilation errors.
type UnsafeRegisterLoginServer interface {
	mustEmbedUnimplementedRegisterLoginServer()
}

func RegisterRegisterLoginServer(s grpc.ServiceRegistrar, srv RegisterLoginServer) {
	s.RegisterService(&RegisterLogin_ServiceDesc, srv)
}

func _RegisterLogin_UserRegister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRegisterReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegisterLoginServer).UserRegister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegisterLogin_UserRegister_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegisterLoginServer).UserRegister(ctx, req.(*UserRegisterReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegisterLogin_UserLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserLoginReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegisterLoginServer).UserLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegisterLogin_UserLogin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegisterLoginServer).UserLogin(ctx, req.(*UserLoginReq))
	}
	return interceptor(ctx, in, info, handler)
}

// RegisterLogin_ServiceDesc is the grpc.ServiceDesc for RegisterLogin service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RegisterLogin_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.RegisterLogin",
	HandlerType: (*RegisterLoginServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UserRegister",
			Handler:    _RegisterLogin_UserRegister_Handler,
		},
		{
			MethodName: "UserLogin",
			Handler:    _RegisterLogin_UserLogin_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "user.proto",
}

const (
	BaseInfo_GetBaseInfo_FullMethodName      = "/user.BaseInfo/GetBaseInfo"
	BaseInfo_SearchByUsername_FullMethodName = "/user.BaseInfo/SearchByUsername"
	BaseInfo_UpdateUsername_FullMethodName   = "/user.BaseInfo/UpdateUsername"
	BaseInfo_UpdatePassword_FullMethodName   = "/user.BaseInfo/UpdatePassword"
	BaseInfo_ForgetPassword_FullMethodName   = "/user.BaseInfo/ForgetPassword"
	BaseInfo_UpdateEmail_FullMethodName      = "/user.BaseInfo/UpdateEmail"
	BaseInfo_UpdatePermission_FullMethodName = "/user.BaseInfo/UpdatePermission"
)

// BaseInfoClient is the client API for BaseInfo service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 用户基本信息
type BaseInfoClient interface {
	// 获取用户基本信息，不包括密码，并缓存
	GetBaseInfo(ctx context.Context, in *GetBaseInfoReq, opts ...grpc.CallOption) (*GetBaseInfoResp, error)
	// 根据用户名搜索用户，并缓存
	SearchByUsername(ctx context.Context, in *SearchByUsernameReq, opts ...grpc.CallOption) (*SearchByUsernameResp, error)
	// 修改用户名，有7天冷却期
	UpdateUsername(ctx context.Context, in *UpdateUsernameReq, opts ...grpc.CallOption) (*UpdateUsernameResp, error)
	// 修改密码
	UpdatePassword(ctx context.Context, in *UpdatePasswordReq, opts ...grpc.CallOption) (*UpdatePasswordResp, error)
	// 忘记密码
	ForgetPassword(ctx context.Context, in *ForgetPasswordReq, opts ...grpc.CallOption) (*ForgetPasswordResp, error)
	// 修改用户邮箱，有7天冷却期
	UpdateEmail(ctx context.Context, in *UpdateEmailReq, opts ...grpc.CallOption) (*UpdateEmailResp, error)
	// 修改用户权限，需要管理员权限
	UpdatePermission(ctx context.Context, in *UpdatePermissionReq, opts ...grpc.CallOption) (*UpdatePermissionResp, error)
}

type baseInfoClient struct {
	cc grpc.ClientConnInterface
}

func NewBaseInfoClient(cc grpc.ClientConnInterface) BaseInfoClient {
	return &baseInfoClient{cc}
}

func (c *baseInfoClient) GetBaseInfo(ctx context.Context, in *GetBaseInfoReq, opts ...grpc.CallOption) (*GetBaseInfoResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBaseInfoResp)
	err := c.cc.Invoke(ctx, BaseInfo_GetBaseInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseInfoClient) SearchByUsername(ctx context.Context, in *SearchByUsernameReq, opts ...grpc.CallOption) (*SearchByUsernameResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchByUsernameResp)
	err := c.cc.Invoke(ctx, BaseInfo_SearchByUsername_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseInfoClient) UpdateUsername(ctx context.Context, in *UpdateUsernameReq, opts ...grpc.CallOption) (*UpdateUsernameResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateUsernameResp)
	err := c.cc.Invoke(ctx, BaseInfo_UpdateUsername_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseInfoClient) UpdatePassword(ctx context.Context, in *UpdatePasswordReq, opts ...grpc.CallOption) (*UpdatePasswordResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdatePasswordResp)
	err := c.cc.Invoke(ctx, BaseInfo_UpdatePassword_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseInfoClient) ForgetPassword(ctx context.Context, in *ForgetPasswordReq, opts ...grpc.CallOption) (*ForgetPasswordResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ForgetPasswordResp)
	err := c.cc.Invoke(ctx, BaseInfo_ForgetPassword_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseInfoClient) UpdateEmail(ctx context.Context, in *UpdateEmailReq, opts ...grpc.CallOption) (*UpdateEmailResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateEmailResp)
	err := c.cc.Invoke(ctx, BaseInfo_UpdateEmail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseInfoClient) UpdatePermission(ctx context.Context, in *UpdatePermissionReq, opts ...grpc.CallOption) (*UpdatePermissionResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdatePermissionResp)
	err := c.cc.Invoke(ctx, BaseInfo_UpdatePermission_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BaseInfoServer is the server API for BaseInfo service.
// All implementations must embed UnimplementedBaseInfoServer
// for forward compatibility
//
// 用户基本信息
type BaseInfoServer interface {
	// 获取用户基本信息，不包括密码，并缓存
	GetBaseInfo(context.Context, *GetBaseInfoReq) (*GetBaseInfoResp, error)
	// 根据用户名搜索用户，并缓存
	SearchByUsername(context.Context, *SearchByUsernameReq) (*SearchByUsernameResp, error)
	// 修改用户名，有7天冷却期
	UpdateUsername(context.Context, *UpdateUsernameReq) (*UpdateUsernameResp, error)
	// 修改密码
	UpdatePassword(context.Context, *UpdatePasswordReq) (*UpdatePasswordResp, error)
	// 忘记密码
	ForgetPassword(context.Context, *ForgetPasswordReq) (*ForgetPasswordResp, error)
	// 修改用户邮箱，有7天冷却期
	UpdateEmail(context.Context, *UpdateEmailReq) (*UpdateEmailResp, error)
	// 修改用户权限，需要管理员权限
	UpdatePermission(context.Context, *UpdatePermissionReq) (*UpdatePermissionResp, error)
	mustEmbedUnimplementedBaseInfoServer()
}

// UnimplementedBaseInfoServer must be embedded to have forward compatible implementations.
type UnimplementedBaseInfoServer struct {
}

func (UnimplementedBaseInfoServer) GetBaseInfo(context.Context, *GetBaseInfoReq) (*GetBaseInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBaseInfo not implemented")
}
func (UnimplementedBaseInfoServer) SearchByUsername(context.Context, *SearchByUsernameReq) (*SearchByUsernameResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchByUsername not implemented")
}
func (UnimplementedBaseInfoServer) UpdateUsername(context.Context, *UpdateUsernameReq) (*UpdateUsernameResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUsername not implemented")
}
func (UnimplementedBaseInfoServer) UpdatePassword(context.Context, *UpdatePasswordReq) (*UpdatePasswordResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePassword not implemented")
}
func (UnimplementedBaseInfoServer) ForgetPassword(context.Context, *ForgetPasswordReq) (*ForgetPasswordResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ForgetPassword not implemented")
}
func (UnimplementedBaseInfoServer) UpdateEmail(context.Context, *UpdateEmailReq) (*UpdateEmailResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateEmail not implemented")
}
func (UnimplementedBaseInfoServer) UpdatePermission(context.Context, *UpdatePermissionReq) (*UpdatePermissionResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePermission not implemented")
}
func (UnimplementedBaseInfoServer) mustEmbedUnimplementedBaseInfoServer() {}

// UnsafeBaseInfoServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BaseInfoServer will
// result in compilation errors.
type UnsafeBaseInfoServer interface {
	mustEmbedUnimplementedBaseInfoServer()
}

func RegisterBaseInfoServer(s grpc.ServiceRegistrar, srv BaseInfoServer) {
	s.RegisterService(&BaseInfo_ServiceDesc, srv)
}

func _BaseInfo_GetBaseInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBaseInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseInfoServer).GetBaseInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BaseInfo_GetBaseInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseInfoServer).GetBaseInfo(ctx, req.(*GetBaseInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseInfo_SearchByUsername_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchByUsernameReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseInfoServer).SearchByUsername(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BaseInfo_SearchByUsername_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseInfoServer).SearchByUsername(ctx, req.(*SearchByUsernameReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseInfo_UpdateUsername_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUsernameReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseInfoServer).UpdateUsername(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BaseInfo_UpdateUsername_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseInfoServer).UpdateUsername(ctx, req.(*UpdateUsernameReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseInfo_UpdatePassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePasswordReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseInfoServer).UpdatePassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BaseInfo_UpdatePassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseInfoServer).UpdatePassword(ctx, req.(*UpdatePasswordReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseInfo_ForgetPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForgetPasswordReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseInfoServer).ForgetPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BaseInfo_ForgetPassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseInfoServer).ForgetPassword(ctx, req.(*ForgetPasswordReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseInfo_UpdateEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateEmailReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseInfoServer).UpdateEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BaseInfo_UpdateEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseInfoServer).UpdateEmail(ctx, req.(*UpdateEmailReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseInfo_UpdatePermission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePermissionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseInfoServer).UpdatePermission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BaseInfo_UpdatePermission_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseInfoServer).UpdatePermission(ctx, req.(*UpdatePermissionReq))
	}
	return interceptor(ctx, in, info, handler)
}

// BaseInfo_ServiceDesc is the grpc.ServiceDesc for BaseInfo service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BaseInfo_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.BaseInfo",
	HandlerType: (*BaseInfoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetBaseInfo",
			Handler:    _BaseInfo_GetBaseInfo_Handler,
		},
		{
			MethodName: "SearchByUsername",
			Handler:    _BaseInfo_SearchByUsername_Handler,
		},
		{
			MethodName: "UpdateUsername",
			Handler:    _BaseInfo_UpdateUsername_Handler,
		},
		{
			MethodName: "UpdatePassword",
			Handler:    _BaseInfo_UpdatePassword_Handler,
		},
		{
			MethodName: "ForgetPassword",
			Handler:    _BaseInfo_ForgetPassword_Handler,
		},
		{
			MethodName: "UpdateEmail",
			Handler:    _BaseInfo_UpdateEmail_Handler,
		},
		{
			MethodName: "UpdatePermission",
			Handler:    _BaseInfo_UpdatePermission_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "user.proto",
}

const (
	Profile_GetUserProfile_FullMethodName            = "/user.Profile/GetUserProfile"
	Profile_UpdateUserProfile_FullMethodName         = "/user.Profile/UpdateUserProfile"
	Profile_AddUserPersonalWebsite_FullMethodName    = "/user.Profile/AddUserPersonalWebsite"
	Profile_DeleteUserPersonalWebsite_FullMethodName = "/user.Profile/DeleteUserPersonalWebsite"
	Profile_AddUserSkill_FullMethodName              = "/user.Profile/AddUserSkill"
	Profile_DeleteUserSkill_FullMethodName           = "/user.Profile/DeleteUserSkill"
)

// ProfileClient is the client API for Profile service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 用户简介
type ProfileClient interface {
	// 获取用户简介
	GetUserProfile(ctx context.Context, in *GetUserInfoReq, opts ...grpc.CallOption) (*GetUserInfoResp, error)
	// 修改用户简介，不包括个人网站和用户技能
	UpdateUserProfile(ctx context.Context, in *UpdateUserProfileReq, opts ...grpc.CallOption) (*UpdateUserProfileResp, error)
	// 添加个人网站，最多5个
	AddUserPersonalWebsite(ctx context.Context, in *AddUserPersonalWebsiteReq, opts ...grpc.CallOption) (*AddUserPersonalWebsiteResp, error)
	// 删除个人网站
	DeleteUserPersonalWebsite(ctx context.Context, in *DeleteUserPersonalWebsiteReq, opts ...grpc.CallOption) (*DeleteUserPersonalWebsiteResp, error)
	// 添加用户技能，最多10个
	AddUserSkill(ctx context.Context, in *AddUserSkillReq, opts ...grpc.CallOption) (*AddUserSkillResp, error)
	// 删除用户技能
	DeleteUserSkill(ctx context.Context, in *DeleteUserSkillReq, opts ...grpc.CallOption) (*DeleteUserSkillResp, error)
}

type profileClient struct {
	cc grpc.ClientConnInterface
}

func NewProfileClient(cc grpc.ClientConnInterface) ProfileClient {
	return &profileClient{cc}
}

func (c *profileClient) GetUserProfile(ctx context.Context, in *GetUserInfoReq, opts ...grpc.CallOption) (*GetUserInfoResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserInfoResp)
	err := c.cc.Invoke(ctx, Profile_GetUserProfile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *profileClient) UpdateUserProfile(ctx context.Context, in *UpdateUserProfileReq, opts ...grpc.CallOption) (*UpdateUserProfileResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateUserProfileResp)
	err := c.cc.Invoke(ctx, Profile_UpdateUserProfile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *profileClient) AddUserPersonalWebsite(ctx context.Context, in *AddUserPersonalWebsiteReq, opts ...grpc.CallOption) (*AddUserPersonalWebsiteResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddUserPersonalWebsiteResp)
	err := c.cc.Invoke(ctx, Profile_AddUserPersonalWebsite_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *profileClient) DeleteUserPersonalWebsite(ctx context.Context, in *DeleteUserPersonalWebsiteReq, opts ...grpc.CallOption) (*DeleteUserPersonalWebsiteResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteUserPersonalWebsiteResp)
	err := c.cc.Invoke(ctx, Profile_DeleteUserPersonalWebsite_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *profileClient) AddUserSkill(ctx context.Context, in *AddUserSkillReq, opts ...grpc.CallOption) (*AddUserSkillResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddUserSkillResp)
	err := c.cc.Invoke(ctx, Profile_AddUserSkill_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *profileClient) DeleteUserSkill(ctx context.Context, in *DeleteUserSkillReq, opts ...grpc.CallOption) (*DeleteUserSkillResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteUserSkillResp)
	err := c.cc.Invoke(ctx, Profile_DeleteUserSkill_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProfileServer is the server API for Profile service.
// All implementations must embed UnimplementedProfileServer
// for forward compatibility
//
// 用户简介
type ProfileServer interface {
	// 获取用户简介
	GetUserProfile(context.Context, *GetUserInfoReq) (*GetUserInfoResp, error)
	// 修改用户简介，不包括个人网站和用户技能
	UpdateUserProfile(context.Context, *UpdateUserProfileReq) (*UpdateUserProfileResp, error)
	// 添加个人网站，最多5个
	AddUserPersonalWebsite(context.Context, *AddUserPersonalWebsiteReq) (*AddUserPersonalWebsiteResp, error)
	// 删除个人网站
	DeleteUserPersonalWebsite(context.Context, *DeleteUserPersonalWebsiteReq) (*DeleteUserPersonalWebsiteResp, error)
	// 添加用户技能，最多10个
	AddUserSkill(context.Context, *AddUserSkillReq) (*AddUserSkillResp, error)
	// 删除用户技能
	DeleteUserSkill(context.Context, *DeleteUserSkillReq) (*DeleteUserSkillResp, error)
	mustEmbedUnimplementedProfileServer()
}

// UnimplementedProfileServer must be embedded to have forward compatible implementations.
type UnimplementedProfileServer struct {
}

func (UnimplementedProfileServer) GetUserProfile(context.Context, *GetUserInfoReq) (*GetUserInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserProfile not implemented")
}
func (UnimplementedProfileServer) UpdateUserProfile(context.Context, *UpdateUserProfileReq) (*UpdateUserProfileResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserProfile not implemented")
}
func (UnimplementedProfileServer) AddUserPersonalWebsite(context.Context, *AddUserPersonalWebsiteReq) (*AddUserPersonalWebsiteResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddUserPersonalWebsite not implemented")
}
func (UnimplementedProfileServer) DeleteUserPersonalWebsite(context.Context, *DeleteUserPersonalWebsiteReq) (*DeleteUserPersonalWebsiteResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUserPersonalWebsite not implemented")
}
func (UnimplementedProfileServer) AddUserSkill(context.Context, *AddUserSkillReq) (*AddUserSkillResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddUserSkill not implemented")
}
func (UnimplementedProfileServer) DeleteUserSkill(context.Context, *DeleteUserSkillReq) (*DeleteUserSkillResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUserSkill not implemented")
}
func (UnimplementedProfileServer) mustEmbedUnimplementedProfileServer() {}

// UnsafeProfileServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProfileServer will
// result in compilation errors.
type UnsafeProfileServer interface {
	mustEmbedUnimplementedProfileServer()
}

func RegisterProfileServer(s grpc.ServiceRegistrar, srv ProfileServer) {
	s.RegisterService(&Profile_ServiceDesc, srv)
}

func _Profile_GetUserProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProfileServer).GetUserProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Profile_GetUserProfile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProfileServer).GetUserProfile(ctx, req.(*GetUserInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Profile_UpdateUserProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserProfileReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProfileServer).UpdateUserProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Profile_UpdateUserProfile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProfileServer).UpdateUserProfile(ctx, req.(*UpdateUserProfileReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Profile_AddUserPersonalWebsite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddUserPersonalWebsiteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProfileServer).AddUserPersonalWebsite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Profile_AddUserPersonalWebsite_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProfileServer).AddUserPersonalWebsite(ctx, req.(*AddUserPersonalWebsiteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Profile_DeleteUserPersonalWebsite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserPersonalWebsiteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProfileServer).DeleteUserPersonalWebsite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Profile_DeleteUserPersonalWebsite_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProfileServer).DeleteUserPersonalWebsite(ctx, req.(*DeleteUserPersonalWebsiteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Profile_AddUserSkill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddUserSkillReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProfileServer).AddUserSkill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Profile_AddUserSkill_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProfileServer).AddUserSkill(ctx, req.(*AddUserSkillReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Profile_DeleteUserSkill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserSkillReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProfileServer).DeleteUserSkill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Profile_DeleteUserSkill_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProfileServer).DeleteUserSkill(ctx, req.(*DeleteUserSkillReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Profile_ServiceDesc is the grpc.ServiceDesc for Profile service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Profile_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.Profile",
	HandlerType: (*ProfileServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUserProfile",
			Handler:    _Profile_GetUserProfile_Handler,
		},
		{
			MethodName: "UpdateUserProfile",
			Handler:    _Profile_UpdateUserProfile_Handler,
		},
		{
			MethodName: "AddUserPersonalWebsite",
			Handler:    _Profile_AddUserPersonalWebsite_Handler,
		},
		{
			MethodName: "DeleteUserPersonalWebsite",
			Handler:    _Profile_DeleteUserPersonalWebsite_Handler,
		},
		{
			MethodName: "AddUserSkill",
			Handler:    _Profile_AddUserSkill_Handler,
		},
		{
			MethodName: "DeleteUserSkill",
			Handler:    _Profile_DeleteUserSkill_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "user.proto",
}

const (
	Follow_GetFollowings_FullMethodName = "/user.Follow/GetFollowings"
	Follow_GetFans_FullMethodName       = "/user.Follow/GetFans"
	Follow_FollowUser_FullMethodName    = "/user.Follow/FollowUser"
)

// FollowClient is the client API for Follow service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 关注
type FollowClient interface {
	// 获取所有关注，分页查询
	GetFollowings(ctx context.Context, in *GetFollowingsReq, opts ...grpc.CallOption) (*GetFollowingsResp, error)
	// 获取所有粉丝，分页查询
	GetFans(ctx context.Context, in *GetFansReq, opts ...grpc.CallOption) (*GetFansResp, error)
	// 关注其他用户
	FollowUser(ctx context.Context, in *FollowUserReq, opts ...grpc.CallOption) (*FollowUserResp, error)
}

type followClient struct {
	cc grpc.ClientConnInterface
}

func NewFollowClient(cc grpc.ClientConnInterface) FollowClient {
	return &followClient{cc}
}

func (c *followClient) GetFollowings(ctx context.Context, in *GetFollowingsReq, opts ...grpc.CallOption) (*GetFollowingsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetFollowingsResp)
	err := c.cc.Invoke(ctx, Follow_GetFollowings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *followClient) GetFans(ctx context.Context, in *GetFansReq, opts ...grpc.CallOption) (*GetFansResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetFansResp)
	err := c.cc.Invoke(ctx, Follow_GetFans_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *followClient) FollowUser(ctx context.Context, in *FollowUserReq, opts ...grpc.CallOption) (*FollowUserResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FollowUserResp)
	err := c.cc.Invoke(ctx, Follow_FollowUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FollowServer is the server API for Follow service.
// All implementations must embed UnimplementedFollowServer
// for forward compatibility
//
// 关注
type FollowServer interface {
	// 获取所有关注，分页查询
	GetFollowings(context.Context, *GetFollowingsReq) (*GetFollowingsResp, error)
	// 获取所有粉丝，分页查询
	GetFans(context.Context, *GetFansReq) (*GetFansResp, error)
	// 关注其他用户
	FollowUser(context.Context, *FollowUserReq) (*FollowUserResp, error)
	mustEmbedUnimplementedFollowServer()
}

// UnimplementedFollowServer must be embedded to have forward compatible implementations.
type UnimplementedFollowServer struct {
}

func (UnimplementedFollowServer) GetFollowings(context.Context, *GetFollowingsReq) (*GetFollowingsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFollowings not implemented")
}
func (UnimplementedFollowServer) GetFans(context.Context, *GetFansReq) (*GetFansResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFans not implemented")
}
func (UnimplementedFollowServer) FollowUser(context.Context, *FollowUserReq) (*FollowUserResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FollowUser not implemented")
}
func (UnimplementedFollowServer) mustEmbedUnimplementedFollowServer() {}

// UnsafeFollowServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FollowServer will
// result in compilation errors.
type UnsafeFollowServer interface {
	mustEmbedUnimplementedFollowServer()
}

func RegisterFollowServer(s grpc.ServiceRegistrar, srv FollowServer) {
	s.RegisterService(&Follow_ServiceDesc, srv)
}

func _Follow_GetFollowings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFollowingsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FollowServer).GetFollowings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Follow_GetFollowings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FollowServer).GetFollowings(ctx, req.(*GetFollowingsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Follow_GetFans_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFansReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FollowServer).GetFans(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Follow_GetFans_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FollowServer).GetFans(ctx, req.(*GetFansReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Follow_FollowUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FollowUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FollowServer).FollowUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Follow_FollowUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FollowServer).FollowUser(ctx, req.(*FollowUserReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Follow_ServiceDesc is the grpc.ServiceDesc for Follow service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Follow_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.Follow",
	HandlerType: (*FollowServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetFollowings",
			Handler:    _Follow_GetFollowings_Handler,
		},
		{
			MethodName: "GetFans",
			Handler:    _Follow_GetFans_Handler,
		},
		{
			MethodName: "FollowUser",
			Handler:    _Follow_FollowUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "user.proto",
}

const (
	Other_AddCity_FullMethodName         = "/user.Other/AddCity"
	Other_DeleteCity_FullMethodName      = "/user.Other/DeleteCity"
	Other_MustDeleteCity_FullMethodName  = "/user.Other/MustDeleteCity"
	Other_AddSkill_FullMethodName        = "/user.Other/AddSkill"
	Other_DeleteSkill_FullMethodName     = "/user.Other/DeleteSkill"
	Other_MustDeleteSkill_FullMethodName = "/user.Other/MustDeleteSkill"
)

// OtherClient is the client API for Other service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 其他
type OtherClient interface {
	// 添加和删除城市，只有客服能操作
	AddCity(ctx context.Context, in *AddCityReq, opts ...grpc.CallOption) (*AddCityResp, error)
	DeleteCity(ctx context.Context, in *DeleteCityReq, opts ...grpc.CallOption) (*DeleteCityResp, error)
	// 强行删除城市，必须要管理员权限
	MustDeleteCity(ctx context.Context, in *MustDeleteCityReq, opts ...grpc.CallOption) (*MustDeleteCityResp, error)
	// 添加和删除技能，只有客服能操作
	AddSkill(ctx context.Context, in *AddSkillReq, opts ...grpc.CallOption) (*AddSkillResp, error)
	DeleteSkill(ctx context.Context, in *DeleteSkillReq, opts ...grpc.CallOption) (*DeleteSkillResp, error)
	// 强行删除技能，必须要管理员权限
	MustDeleteSkill(ctx context.Context, in *MustDeleteSkillReq, opts ...grpc.CallOption) (*MustDeleteSkillResp, error)
}

type otherClient struct {
	cc grpc.ClientConnInterface
}

func NewOtherClient(cc grpc.ClientConnInterface) OtherClient {
	return &otherClient{cc}
}

func (c *otherClient) AddCity(ctx context.Context, in *AddCityReq, opts ...grpc.CallOption) (*AddCityResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddCityResp)
	err := c.cc.Invoke(ctx, Other_AddCity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *otherClient) DeleteCity(ctx context.Context, in *DeleteCityReq, opts ...grpc.CallOption) (*DeleteCityResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteCityResp)
	err := c.cc.Invoke(ctx, Other_DeleteCity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *otherClient) MustDeleteCity(ctx context.Context, in *MustDeleteCityReq, opts ...grpc.CallOption) (*MustDeleteCityResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MustDeleteCityResp)
	err := c.cc.Invoke(ctx, Other_MustDeleteCity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *otherClient) AddSkill(ctx context.Context, in *AddSkillReq, opts ...grpc.CallOption) (*AddSkillResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddSkillResp)
	err := c.cc.Invoke(ctx, Other_AddSkill_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *otherClient) DeleteSkill(ctx context.Context, in *DeleteSkillReq, opts ...grpc.CallOption) (*DeleteSkillResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteSkillResp)
	err := c.cc.Invoke(ctx, Other_DeleteSkill_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *otherClient) MustDeleteSkill(ctx context.Context, in *MustDeleteSkillReq, opts ...grpc.CallOption) (*MustDeleteSkillResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MustDeleteSkillResp)
	err := c.cc.Invoke(ctx, Other_MustDeleteSkill_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OtherServer is the server API for Other service.
// All implementations must embed UnimplementedOtherServer
// for forward compatibility
//
// 其他
type OtherServer interface {
	// 添加和删除城市，只有客服能操作
	AddCity(context.Context, *AddCityReq) (*AddCityResp, error)
	DeleteCity(context.Context, *DeleteCityReq) (*DeleteCityResp, error)
	// 强行删除城市，必须要管理员权限
	MustDeleteCity(context.Context, *MustDeleteCityReq) (*MustDeleteCityResp, error)
	// 添加和删除技能，只有客服能操作
	AddSkill(context.Context, *AddSkillReq) (*AddSkillResp, error)
	DeleteSkill(context.Context, *DeleteSkillReq) (*DeleteSkillResp, error)
	// 强行删除技能，必须要管理员权限
	MustDeleteSkill(context.Context, *MustDeleteSkillReq) (*MustDeleteSkillResp, error)
	mustEmbedUnimplementedOtherServer()
}

// UnimplementedOtherServer must be embedded to have forward compatible implementations.
type UnimplementedOtherServer struct {
}

func (UnimplementedOtherServer) AddCity(context.Context, *AddCityReq) (*AddCityResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCity not implemented")
}
func (UnimplementedOtherServer) DeleteCity(context.Context, *DeleteCityReq) (*DeleteCityResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCity not implemented")
}
func (UnimplementedOtherServer) MustDeleteCity(context.Context, *MustDeleteCityReq) (*MustDeleteCityResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MustDeleteCity not implemented")
}
func (UnimplementedOtherServer) AddSkill(context.Context, *AddSkillReq) (*AddSkillResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddSkill not implemented")
}
func (UnimplementedOtherServer) DeleteSkill(context.Context, *DeleteSkillReq) (*DeleteSkillResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSkill not implemented")
}
func (UnimplementedOtherServer) MustDeleteSkill(context.Context, *MustDeleteSkillReq) (*MustDeleteSkillResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MustDeleteSkill not implemented")
}
func (UnimplementedOtherServer) mustEmbedUnimplementedOtherServer() {}

// UnsafeOtherServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OtherServer will
// result in compilation errors.
type UnsafeOtherServer interface {
	mustEmbedUnimplementedOtherServer()
}

func RegisterOtherServer(s grpc.ServiceRegistrar, srv OtherServer) {
	s.RegisterService(&Other_ServiceDesc, srv)
}

func _Other_AddCity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddCityReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OtherServer).AddCity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Other_AddCity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OtherServer).AddCity(ctx, req.(*AddCityReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Other_DeleteCity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCityReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OtherServer).DeleteCity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Other_DeleteCity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OtherServer).DeleteCity(ctx, req.(*DeleteCityReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Other_MustDeleteCity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MustDeleteCityReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OtherServer).MustDeleteCity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Other_MustDeleteCity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OtherServer).MustDeleteCity(ctx, req.(*MustDeleteCityReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Other_AddSkill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddSkillReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OtherServer).AddSkill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Other_AddSkill_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OtherServer).AddSkill(ctx, req.(*AddSkillReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Other_DeleteSkill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSkillReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OtherServer).DeleteSkill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Other_DeleteSkill_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OtherServer).DeleteSkill(ctx, req.(*DeleteSkillReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Other_MustDeleteSkill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MustDeleteSkillReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OtherServer).MustDeleteSkill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Other_MustDeleteSkill_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OtherServer).MustDeleteSkill(ctx, req.(*MustDeleteSkillReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Other_ServiceDesc is the grpc.ServiceDesc for Other service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Other_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.Other",
	HandlerType: (*OtherServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddCity",
			Handler:    _Other_AddCity_Handler,
		},
		{
			MethodName: "DeleteCity",
			Handler:    _Other_DeleteCity_Handler,
		},
		{
			MethodName: "MustDeleteCity",
			Handler:    _Other_MustDeleteCity_Handler,
		},
		{
			MethodName: "AddSkill",
			Handler:    _Other_AddSkill_Handler,
		},
		{
			MethodName: "DeleteSkill",
			Handler:    _Other_DeleteSkill_Handler,
		},
		{
			MethodName: "MustDeleteSkill",
			Handler:    _Other_MustDeleteSkill_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "user.proto",
}
